<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LazyMatrix: LazyMatrix Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">LazyMatrix
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">LazyMatrix Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1AugmentColumns.html">AugmentColumns</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Augments two matrices by columns to create a new matrix.  <a href="structLazyMatrix_1_1AugmentColumns.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1AugmentColumnsView.html">AugmentColumnsView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Augments two matrices by columns to create a new matrix view.  <a href="structLazyMatrix_1_1AugmentColumnsView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1AugmentRows.html">AugmentRows</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Augments two matrices by rows to create a new matrix.  <a href="structLazyMatrix_1_1AugmentRows.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1AugmentRowsView.html">AugmentRowsView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Augments two matrices by rows to create a new matrix view.  <a href="structLazyMatrix_1_1AugmentRowsView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1BaseMatrix.html">BaseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for matrix expressions.  <a href="classLazyMatrix_1_1BaseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1BaseMatrix3D.html">BaseMatrix3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for 3D matrix expressions.  <a href="classLazyMatrix_1_1BaseMatrix3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1CircularIterator.html">CircularIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A circular iterator for iterating over containers.  <a href="classLazyMatrix_1_1CircularIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1ColumnSelector.html">ColumnSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for selecting specific columns from a matrix.  <a href="structLazyMatrix_1_1ColumnSelector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1ColumnSelectorView.html">ColumnSelectorView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for creating a view that selects specific columns from a matrix.  <a href="structLazyMatrix_1_1ColumnSelectorView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1ConstantBorder.html">ConstantBorder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles border cases by returning a constant value.  <a href="structLazyMatrix_1_1ConstantBorder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1ConstantBorderView.html">ConstantBorderView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View that handles border cases by returning a constant value.  <a href="structLazyMatrix_1_1ConstantBorderView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1CSVMatrix.html">CSVMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory-mapped CSV file reader providing matrix-like access to data.  <a href="classLazyMatrix_1_1CSVMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1DatabaseMatrix.html">DatabaseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents and accesses a SQL database table as a 2D matrix.  <a href="classLazyMatrix_1_1DatabaseMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1DatabaseWindow.html">DatabaseWindow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a window of cached data from the database.  <a href="structLazyMatrix_1_1DatabaseWindow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1Difference.html">Difference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes first-order differences of a matrix.  <a href="structLazyMatrix_1_1Difference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1ElementByElementBinaryExpression.html">ElementByElementBinaryExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to represent element-by-element binary operations between two matrices.  <a href="structLazyMatrix_1_1ElementByElementBinaryExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1ElementByElementUnaryExpression.html">ElementByElementUnaryExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to represent element-by-element unary operations on a matrix.  <a href="structLazyMatrix_1_1ElementByElementUnaryExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1ExpressionEvaluator.html">ExpressionEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to evaluate mathematical expressions.  <a href="classLazyMatrix_1_1ExpressionEvaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1ImageMatrix.html">ImageMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that represents an image matrix, serving as an interface to dlib's image handling.  <a href="classLazyMatrix_1_1ImageMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1Interval.html">Interval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a numerical interval and provides arithmetic operations.  <a href="classLazyMatrix_1_1Interval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1Iota.html">Iota</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to generate matrices with incrementally increasing values.  <a href="classLazyMatrix_1_1Iota.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix3d.html">is_type_a_matrix3d</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix3d_3_01BaseMatrix3D_3_01MatrixType_01_4_01_4.html">is_type_a_matrix3d&lt; BaseMatrix3D&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix3d_3_01Matrix3D_3_01DataType_01_4_01_4.html">is_type_a_matrix3d&lt; Matrix3D&lt; DataType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix3d_3_01PolymorphicMatrixWrapper3D_3_01MatrixType_01_4_01_4.html">is_type_a_matrix3d&lt; PolymorphicMatrixWrapper3D&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time function to check if the type is a matrix expression type.  <a href="structLazyMatrix_1_1is__type__a__matrix3d_3_01PolymorphicMatrixWrapper3D_3_01MatrixType_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix3d_3_01SimpleData3DMatrixWrapper_3_01SimpleDataType_01_4_01_4.html">is_type_a_matrix3d&lt; SimpleData3DMatrixWrapper&lt; SimpleDataType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix3d_3_01SimpleMatrix3D_3_01DataType_01_4_01_4.html">is_type_a_matrix3d&lt; SimpleMatrix3D&lt; DataType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01AugmentColumns_3_01MatrixType1_00_01MatrixType2_01_4_01_4.html">is_type_a_matrix&lt; AugmentColumns&lt; MatrixType1, MatrixType2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01AugmentColumnsView_3_01MatrixType1_00_01MatrixType2_01_4_01_4.html">is_type_a_matrix&lt; AugmentColumnsView&lt; MatrixType1, MatrixType2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01AugmentRows_3_01MatrixType1_00_01MatrixType2_01_4_01_4.html">is_type_a_matrix&lt; AugmentRows&lt; MatrixType1, MatrixType2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01AugmentRowsView_3_01MatrixType1_00_01MatrixType2_01_4_01_4.html">is_type_a_matrix&lt; AugmentRowsView&lt; MatrixType1, MatrixType2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01BaseMatrix_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; BaseMatrix&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01ColumnSelector_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; ColumnSelector&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01ColumnSelectorView_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; ColumnSelectorView&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01ConstantBorder_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; ConstantBorder&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01ConstantBorderView_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; ConstantBorderView&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01CSVMatrix_3_01DataType_01_4_01_4.html">is_type_a_matrix&lt; CSVMatrix&lt; DataType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01DatabaseMatrix_01_4.html">is_type_a_matrix&lt; DatabaseMatrix &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01Difference_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; Difference&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01ElementByElementBinaryExpression_3_01MatrixType1_00_01MatrixType2_01_4_01_4.html">is_type_a_matrix&lt; ElementByElementBinaryExpression&lt; MatrixType1, MatrixType2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01ElementByElementUnaryExpression_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; ElementByElementUnaryExpression&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01ImageMatrix_3_01DataType_01_4_01_4.html">is_type_a_matrix&lt; ImageMatrix&lt; DataType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01Iota_3_01DataType_01_4_01_4.html">is_type_a_matrix&lt; Iota&lt; DataType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01Matrix_3_01DataType_01_4_01_4.html">is_type_a_matrix&lt; Matrix&lt; DataType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01PaddedMatrix_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; PaddedMatrix&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01PaddedMatrixView_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; PaddedMatrixView&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01PolymorphicMatrixWrapper_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; PolymorphicMatrixWrapper&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile time function to check if the type is a matrix expression type.  <a href="structLazyMatrix_1_1is__type__a__matrix_3_01PolymorphicMatrixWrapper_3_01MatrixType_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01RandomMatrix_3_01DataType_01_4_01_4.html">is_type_a_matrix&lt; RandomMatrix&lt; DataType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01RepeatedBorder_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; RepeatedBorder&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01RepeatedBorderView_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; RepeatedBorderView&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01Reverse_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; Reverse&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01ReverseView_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; ReverseView&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01ROI_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; ROI&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01ROIView_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; ROIView&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01RowAndColumnSelector_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; RowAndColumnSelector&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01RowAndColumnSelectorView_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; RowAndColumnSelectorView&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01RowSelector_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; RowSelector&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01RowSelectorView_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; RowSelectorView&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01Shuffle_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; Shuffle&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01ShuffleView_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; ShuffleView&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01SimpleData2DMatrixWrapper_3_01SimpleDataType_01_4_01_4.html">is_type_a_matrix&lt; SimpleData2DMatrixWrapper&lt; SimpleDataType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01SimpleMatrix_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; SimpleMatrix&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01SimpleMovingAverageOfColumns_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; SimpleMovingAverageOfColumns&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01SimpleMovingAverageOfRows_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; SimpleMovingAverageOfRows&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01SineWaveMatrix_3_01DataType_01_4_01_4.html">is_type_a_matrix&lt; SineWaveMatrix&lt; DataType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01SingleColumnSelector_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; SingleColumnSelector&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01SingleColumnSelectorView_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; SingleColumnSelectorView&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01SingleRowSelector_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; SingleRowSelector&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01SingleRowSelectorView_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; SingleRowSelectorView&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01Sorted_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; Sorted&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01SortedView_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; SortedView&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01Transpose_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; Transpose&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__type__a__matrix_3_01TransposeView_3_01MatrixType_01_4_01_4.html">is_type_a_matrix&lt; TransposeView&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__valid__dlib__pixel__type.html">is_valid_dlib_pixel_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to check if a type is a valid pixel type for use with dlib.  <a href="structLazyMatrix_1_1is__valid__dlib__pixel__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__valid__dlib__pixel__type_3_01dlib_1_1bgr__alpha__pixel_01_4.html">is_valid_dlib_pixel_type&lt; dlib::bgr_alpha_pixel &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__valid__dlib__pixel__type_3_01dlib_1_1bgr__pixel_01_4.html">is_valid_dlib_pixel_type&lt; dlib::bgr_pixel &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__valid__dlib__pixel__type_3_01dlib_1_1hsi__pixel_01_4.html">is_valid_dlib_pixel_type&lt; dlib::hsi_pixel &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__valid__dlib__pixel__type_3_01dlib_1_1hsv__pixel_01_4.html">is_valid_dlib_pixel_type&lt; dlib::hsv_pixel &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__valid__dlib__pixel__type_3_01dlib_1_1lab__pixel_01_4.html">is_valid_dlib_pixel_type&lt; dlib::lab_pixel &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__valid__dlib__pixel__type_3_01dlib_1_1rgb__alpha__pixel_01_4.html">is_valid_dlib_pixel_type&lt; dlib::rgb_alpha_pixel &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__valid__dlib__pixel__type_3_01dlib_1_1rgb__pixel_01_4.html">is_valid_dlib_pixel_type&lt; dlib::rgb_pixel &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__valid__dlib__pixel__type_3_01double_01_4.html">is_valid_dlib_pixel_type&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__valid__dlib__pixel__type_3_01float_01_4.html">is_valid_dlib_pixel_type&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__valid__dlib__pixel__type_3_01int_01_4.html">is_valid_dlib_pixel_type&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__valid__dlib__pixel__type_3_01short_01_4.html">is_valid_dlib_pixel_type&lt; short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__valid__dlib__pixel__type_3_01signed_01char_01_4.html">is_valid_dlib_pixel_type&lt; signed char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__valid__dlib__pixel__type_3_01std_1_1complex_3_01double_01_4_01_4.html">is_valid_dlib_pixel_type&lt; std::complex&lt; double &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__valid__dlib__pixel__type_3_01std_1_1complex_3_01float_01_4_01_4.html">is_valid_dlib_pixel_type&lt; std::complex&lt; float &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__valid__dlib__pixel__type_3_01unsigned_01char_01_4.html">is_valid_dlib_pixel_type&lt; unsigned char &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__valid__dlib__pixel__type_3_01unsigned_01int_01_4.html">is_valid_dlib_pixel_type&lt; unsigned int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1is__valid__dlib__pixel__type_3_01unsigned_01short_01_4.html">is_valid_dlib_pixel_type&lt; unsigned short &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1Matrix.html">Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class for a matrix that utilizes memory-mapped files for storage.  <a href="classLazyMatrix_1_1Matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1Matrix3D.html">Matrix3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1Matrix3DFooter.html">Matrix3DFooter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1Matrix3DHeader.html">Matrix3DHeader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1MatrixFooter.html">MatrixFooter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct representing the footer of a memory-mapped matrix.  <a href="structLazyMatrix_1_1MatrixFooter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1MatrixHeader.html">MatrixHeader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct representing the header of a memory-mapped matrix.  <a href="structLazyMatrix_1_1MatrixHeader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1PaddedMatrix.html">PaddedMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pads matrix expression with a constant value.  <a href="structLazyMatrix_1_1PaddedMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1PaddedMatrixView.html">PaddedMatrixView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1PolymorphicMatrix.html">PolymorphicMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class providing a polymorphic interface for matrix-like data.  <a href="classLazyMatrix_1_1PolymorphicMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1PolymorphicMatrix3D.html">PolymorphicMatrix3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class providing a polymorphic interface for 3d-matrix-like data.  <a href="classLazyMatrix_1_1PolymorphicMatrix3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1PolymorphicMatrixWrapper.html">PolymorphicMatrixWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class that provides a polymorphic interface to a given matrix type.  <a href="classLazyMatrix_1_1PolymorphicMatrixWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1PolymorphicMatrixWrapper3D.html">PolymorphicMatrixWrapper3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper class that provides a polymorphic interface to a given 3d-matrix type.  <a href="classLazyMatrix_1_1PolymorphicMatrixWrapper3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1PythonStdOutErrStreamRedirect.html">PythonStdOutErrStreamRedirect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Captures and redirects C++ std::cout/std::cerr and Python's stdout/stderr streams.  <a href="classLazyMatrix_1_1PythonStdOutErrStreamRedirect.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1RandomMatrix.html">RandomMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to generate matrices with random values.  <a href="classLazyMatrix_1_1RandomMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1RepeatedBorder.html">RepeatedBorder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles border cases by repeating border values.  <a href="structLazyMatrix_1_1RepeatedBorder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1RepeatedBorderView.html">RepeatedBorderView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">View that handles border cases by repeating border values.  <a href="structLazyMatrix_1_1RepeatedBorderView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1Reverse.html">Reverse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that provides a non-modifiable reversed view of a matrix.  <a href="structLazyMatrix_1_1Reverse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1ReverseView.html">ReverseView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that provides a reversed view of a matrix.  <a href="structLazyMatrix_1_1ReverseView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1RobustMutex.html">RobustMutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutex class that is robust and suitable for inter-process synchronization.  <a href="classLazyMatrix_1_1RobustMutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1ROI.html">ROI</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to create a view representing a Region Of Interest within a matrix.  <a href="structLazyMatrix_1_1ROI.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1ROIView.html">ROIView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to create a view representing a modifiable Region Of Interest within a matrix.  <a href="structLazyMatrix_1_1ROIView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1RowAndColumnSelector.html">RowAndColumnSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for selecting specific rows and columns from a matrix.  <a href="structLazyMatrix_1_1RowAndColumnSelector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1RowAndColumnSelectorView.html">RowAndColumnSelectorView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for creating a view that selects specific rows and columns from a matrix.  <a href="structLazyMatrix_1_1RowAndColumnSelectorView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1RowSelector.html">RowSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for selecting specific rows from a matrix.  <a href="structLazyMatrix_1_1RowSelector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1RowSelectorView.html">RowSelectorView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for creating a view that selects specific rows from a matrix.  <a href="structLazyMatrix_1_1RowSelectorView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1SafeName.html">SafeName</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for validating and encapsulating database identifiers like table and column names.  <a href="classLazyMatrix_1_1SafeName.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1SafeRowSortingMethod.html">SafeRowSortingMethod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for safely handling row sorting methods in database queries.  <a href="classLazyMatrix_1_1SafeRowSortingMethod.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1Shuffle.html">Shuffle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for shuffling rows and/or columns of a matrix expression.  <a href="structLazyMatrix_1_1Shuffle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1ShuffleView.html">ShuffleView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for shuffling rows and/or columns of a matrix expression.  <a href="classLazyMatrix_1_1ShuffleView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1SimpleData2DMatrixWrapper.html">SimpleData2DMatrixWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper class for simple data types to provide a 2D matrix-like interface.  <a href="classLazyMatrix_1_1SimpleData2DMatrixWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1SimpleData3DMatrixWrapper.html">SimpleData3DMatrixWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper class to provide a 3d-matrix-like interface for simple data types.  <a href="classLazyMatrix_1_1SimpleData3DMatrixWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1SimpleMatrix.html">SimpleMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple 2D matrix class using std::vector for storage.  <a href="classLazyMatrix_1_1SimpleMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1SimpleMatrix3D.html">SimpleMatrix3D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple 3D matrix class using std::vector for storage.  <a href="classLazyMatrix_1_1SimpleMatrix3D.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1SimpleMovingAverageOfColumns.html">SimpleMovingAverageOfColumns</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to compute the simple moving average of columns in a matrix.  <a href="structLazyMatrix_1_1SimpleMovingAverageOfColumns.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1SimpleMovingAverageOfRows.html">SimpleMovingAverageOfRows</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to compute the simple moving average of rows in a matrix.  <a href="structLazyMatrix_1_1SimpleMovingAverageOfRows.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1SineWaveMatrix.html">SineWaveMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to generate matrices representing a sine wave.  <a href="classLazyMatrix_1_1SineWaveMatrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1SingleColumnSelector.html">SingleColumnSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for selecting a single column from a matrix.  <a href="structLazyMatrix_1_1SingleColumnSelector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1SingleColumnSelectorView.html">SingleColumnSelectorView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1SingleRowSelector.html">SingleRowSelector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for selecting a single row from a matrix.  <a href="structLazyMatrix_1_1SingleRowSelector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structLazyMatrix_1_1SingleRowSelectorView.html">SingleRowSelectorView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for creating a view that selects a single row from a matrix.  <a href="structLazyMatrix_1_1SingleRowSelectorView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1Sorted.html">Sorted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for sorting rows or columns of a matrix expression using a user specified row or column to use as the sorting vector for all the other rows or columns in the matrix expression.  <a href="classLazyMatrix_1_1Sorted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1SortedView.html">SortedView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for sorting rows or columns of a matrix expression using a user specified row or column to use as the sorting vector for all the other rows or columns in the matrix expression.  <a href="classLazyMatrix_1_1SortedView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1Transpose.html">Transpose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that provides a read-only transposed view of a matrix.  <a href="classLazyMatrix_1_1Transpose.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLazyMatrix_1_1TransposeView.html">TransposeView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A view class that provides a transposed view of a matrix.  <a href="classLazyMatrix_1_1TransposeView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a76f0e21840057cc6abe605c5e3528f56"><td class="memTemplParams" colspan="2">template&lt;typename DataType &gt; </td></tr>
<tr class="memitem:a76f0e21840057cc6abe605c5e3528f56"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a76f0e21840057cc6abe605c5e3528f56">Data</a> = <a class="el" href="classLazyMatrix_1_1PolymorphicMatrix.html">PolymorphicMatrix</a>&lt; DataType &gt;</td></tr>
<tr class="separator:a76f0e21840057cc6abe605c5e3528f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a315430f93fceaf3bb61b6688d8e6a"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a02a315430f93fceaf3bb61b6688d8e6a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a02a315430f93fceaf3bb61b6688d8e6a">SpecializedData</a> = <a class="el" href="classLazyMatrix_1_1PolymorphicMatrixWrapper.html">PolymorphicMatrixWrapper</a>&lt; MatrixType &gt;</td></tr>
<tr class="separator:a02a315430f93fceaf3bb61b6688d8e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc49dc6be2c966f9695d998cb07aca2b"><td class="memTemplParams" colspan="2">template&lt;typename DataType &gt; </td></tr>
<tr class="memitem:acc49dc6be2c966f9695d998cb07aca2b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#acc49dc6be2c966f9695d998cb07aca2b">Data3D</a> = <a class="el" href="classLazyMatrix_1_1PolymorphicMatrix3D.html">PolymorphicMatrix3D</a>&lt; DataType &gt;</td></tr>
<tr class="separator:acc49dc6be2c966f9695d998cb07aca2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e215196948db549e143041b028c5c87"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a1e215196948db549e143041b028c5c87"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a1e215196948db549e143041b028c5c87">SpecializedData3D</a> = <a class="el" href="classLazyMatrix_1_1PolymorphicMatrixWrapper3D.html">PolymorphicMatrixWrapper3D</a>&lt; MatrixType &gt;</td></tr>
<tr class="separator:a1e215196948db549e143041b028c5c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa1f9cbd0c333a1f648cf02ba3be18668"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa1f9cbd0c333a1f648cf02ba3be18668"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#aa1f9cbd0c333a1f648cf02ba3be18668">augment_by_columns</a> (const MatrixType1 &amp;m1, const MatrixType2 &amp;m2)</td></tr>
<tr class="memdesc:aa1f9cbd0c333a1f648cf02ba3be18668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to augment two matrices by columns.  <a href="namespaceLazyMatrix.html#aa1f9cbd0c333a1f648cf02ba3be18668">More...</a><br /></td></tr>
<tr class="separator:aa1f9cbd0c333a1f648cf02ba3be18668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa1103c90a5e411bd0a7d990d20c1e8"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1aa1103c90a5e411bd0a7d990d20c1e8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a1aa1103c90a5e411bd0a7d990d20c1e8">augment_by_columns_view</a> (MatrixType1 &amp;m1, MatrixType2 &amp;m2)</td></tr>
<tr class="memdesc:a1aa1103c90a5e411bd0a7d990d20c1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to augment two matrices by columns.  <a href="namespaceLazyMatrix.html#a1aa1103c90a5e411bd0a7d990d20c1e8">More...</a><br /></td></tr>
<tr class="separator:a1aa1103c90a5e411bd0a7d990d20c1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b18c3470ab6e918c3b05eca61fa150c"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5b18c3470ab6e918c3b05eca61fa150c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a5b18c3470ab6e918c3b05eca61fa150c">augment_by_rows</a> (const MatrixType1 &amp;m1, const MatrixType2 &amp;m2)</td></tr>
<tr class="memdesc:a5b18c3470ab6e918c3b05eca61fa150c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to augment two matrices by rows.  <a href="namespaceLazyMatrix.html#a5b18c3470ab6e918c3b05eca61fa150c">More...</a><br /></td></tr>
<tr class="separator:a5b18c3470ab6e918c3b05eca61fa150c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76342b165d4a5b24bfb578fdf3bc0e5a"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a76342b165d4a5b24bfb578fdf3bc0e5a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a76342b165d4a5b24bfb578fdf3bc0e5a">augment_by_rows_view</a> (MatrixType1 &amp;m1, MatrixType2 &amp;m2)</td></tr>
<tr class="memdesc:a76342b165d4a5b24bfb578fdf3bc0e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to augment two matrices by rows as a view.  <a href="namespaceLazyMatrix.html#a76342b165d4a5b24bfb578fdf3bc0e5a">More...</a><br /></td></tr>
<tr class="separator:a76342b165d4a5b24bfb578fdf3bc0e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b668ad118aef3b7a858d8b4154a1017"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4b668ad118aef3b7a858d8b4154a1017"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a4b668ad118aef3b7a858d8b4154a1017">repeated_border</a> (const MatrixType &amp;m)</td></tr>
<tr class="separator:a4b668ad118aef3b7a858d8b4154a1017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf0808376958b27dc1418d74e66f1b9"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename DataType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:addf0808376958b27dc1418d74e66f1b9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#addf0808376958b27dc1418d74e66f1b9">constant_border</a> (const MatrixType &amp;m, const DataType &amp;constant_value)</td></tr>
<tr class="separator:addf0808376958b27dc1418d74e66f1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ad51607eb87a63c4f6aaaf8fec567f"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a54ad51607eb87a63c4f6aaaf8fec567f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a54ad51607eb87a63c4f6aaaf8fec567f">repeated_border_view</a> (MatrixType &amp;m)</td></tr>
<tr class="separator:a54ad51607eb87a63c4f6aaaf8fec567f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebfb0a26e62bf86fefdaa0fa04b7cff"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename DataType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1ebfb0a26e62bf86fefdaa0fa04b7cff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a1ebfb0a26e62bf86fefdaa0fa04b7cff">constant_border_view</a> (MatrixType &amp;m, const DataType &amp;constant_value)</td></tr>
<tr class="separator:a1ebfb0a26e62bf86fefdaa0fa04b7cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95da13df69fd6c5e47f662af7f3781cf"><td class="memTemplParams" colspan="2">template&lt;typename ContainerType &gt; </td></tr>
<tr class="memitem:a95da13df69fd6c5e47f662af7f3781cf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a95da13df69fd6c5e47f662af7f3781cf">get_circulat_iterator</a> (ContainerType &amp;container, std::ptrdiff_t maximum_number_of_rotations)</td></tr>
<tr class="separator:a95da13df69fd6c5e47f662af7f3781cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322799145aa54f6fb1441ad7a061c664"><td class="memTemplParams" colspan="2">template&lt;typename NumberType &gt; </td></tr>
<tr class="memitem:a322799145aa54f6fb1441ad7a061c664"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a322799145aa54f6fb1441ad7a061c664">from_string</a> (NumberType &amp;resulting_converted_number, const char *string_begin, int position_where_to_begin_converting, int position_where_to_end_converting, const char decimal_point_delimiter)</td></tr>
<tr class="memdesc:a322799145aa54f6fb1441ad7a061c664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a substring of a string to a number.  <a href="namespaceLazyMatrix.html#a322799145aa54f6fb1441ad7a061c664">More...</a><br /></td></tr>
<tr class="separator:a322799145aa54f6fb1441ad7a061c664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a6a8179a7ea910a485250b9587c745"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a18a6a8179a7ea910a485250b9587c745"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a18a6a8179a7ea910a485250b9587c745">diff</a> (const MatrixType &amp;m1, int difference_direction)</td></tr>
<tr class="separator:a18a6a8179a7ea910a485250b9587c745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775d7e1e0e01bb3a7c08fb0ce155a80e"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a775d7e1e0e01bb3a7c08fb0ce155a80e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a775d7e1e0e01bb3a7c08fb0ce155a80e">simple_downsampling</a> (const MatrixType1 &amp;source, MatrixType2 &amp;destination, int64_t start_index, int64_t end_index, bool sample_rows)</td></tr>
<tr class="memdesc:a775d7e1e0e01bb3a7c08fb0ce155a80e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downsamples data from a source matrix to a destination matrix.  <a href="namespaceLazyMatrix.html#a775d7e1e0e01bb3a7c08fb0ce155a80e">More...</a><br /></td></tr>
<tr class="separator:a775d7e1e0e01bb3a7c08fb0ce155a80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed31aad32043cbe8392de552602f6a0"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3ed31aad32043cbe8392de552602f6a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a3ed31aad32043cbe8392de552602f6a0">downsample_lttb</a> (const MatrixType1 &amp;source, MatrixType2 &amp;destination, int64_t source_start_index, int64_t source_end_index)</td></tr>
<tr class="memdesc:a3ed31aad32043cbe8392de552602f6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downsampling a single row or column vector using the Largest Triangle Three Buckets (LTTB) algorithm.  <a href="namespaceLazyMatrix.html#a3ed31aad32043cbe8392de552602f6a0">More...</a><br /></td></tr>
<tr class="separator:a3ed31aad32043cbe8392de552602f6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468302541b193bf6ed59502d558abc0d"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType1 , typename MatrixType2 , typename MatrixType3 , typename MatrixType4 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{} &amp;&amp;<a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{} &amp;&amp;<a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType3 &gt;{} &amp;&amp;<a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType4 &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a468302541b193bf6ed59502d558abc0d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a468302541b193bf6ed59502d558abc0d">downsample_lttb_xy</a> (const MatrixType1 &amp;x_source, const MatrixType2 &amp;y_source, MatrixType3 &amp;x_destination, MatrixType4 &amp;y_destination, int64_t source_start_index, int64_t source_end_index)</td></tr>
<tr class="memdesc:a468302541b193bf6ed59502d558abc0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downsampling x/y data points using the Largest Triangle Three Buckets (LTTB) algorithm.  <a href="namespaceLazyMatrix.html#a468302541b193bf6ed59502d558abc0d">More...</a><br /></td></tr>
<tr class="separator:a468302541b193bf6ed59502d558abc0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6785541359a9cee7b1b887451a15299e"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6785541359a9cee7b1b887451a15299e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a6785541359a9cee7b1b887451a15299e">downsample_lttb_matrix</a> (const MatrixType1 &amp;source_matrix, MatrixType2 &amp;destination_matrix, int64_t start_index, int64_t end_index, bool sample_rows)</td></tr>
<tr class="memdesc:a6785541359a9cee7b1b887451a15299e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downsamples each column or row of a matrix using the Largest Triangle Three Buckets (LTTB) algorithm.  <a href="namespaceLazyMatrix.html#a6785541359a9cee7b1b887451a15299e">More...</a><br /></td></tr>
<tr class="separator:a6785541359a9cee7b1b887451a15299e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eee1e0458366cad64664bb830404d55"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{} &amp;&amp;<a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6eee1e0458366cad64664bb830404d55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a6eee1e0458366cad64664bb830404d55">downsample_lttb_matrix_xy</a> (const MatrixType1 &amp;source_matrix, MatrixType2 &amp;destination_matrix, int64_t x_index, int64_t start_index, int64_t end_index, bool sample_rows)</td></tr>
<tr class="memdesc:a6eee1e0458366cad64664bb830404d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downsamples each column or row of a matrix using the Largest Triangle Three Buckets (LTTB) algorithm for x/y graph downsampling.  <a href="namespaceLazyMatrix.html#a6eee1e0458366cad64664bb830404d55">More...</a><br /></td></tr>
<tr class="separator:a6eee1e0458366cad64664bb830404d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e7efd6cab7d208d40fc5d17afe5632"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a55e7efd6cab7d208d40fc5d17afe5632"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a55e7efd6cab7d208d40fc5d17afe5632">operator+</a> (const MatrixType1 &amp;m1, const MatrixType2 &amp;m2)</td></tr>
<tr class="separator:a55e7efd6cab7d208d40fc5d17afe5632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f5c87dca6dbf2fc891ad7ee6f622508"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6f5c87dca6dbf2fc891ad7ee6f622508"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a6f5c87dca6dbf2fc891ad7ee6f622508">operator-</a> (const MatrixType1 &amp;m1, const MatrixType2 &amp;m2)</td></tr>
<tr class="separator:a6f5c87dca6dbf2fc891ad7ee6f622508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb7ce77ca0421dc366a68b1a2165a149"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aeb7ce77ca0421dc366a68b1a2165a149"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#aeb7ce77ca0421dc366a68b1a2165a149">operator%</a> (const MatrixType1 &amp;m1, const MatrixType2 &amp;m2)</td></tr>
<tr class="separator:aeb7ce77ca0421dc366a68b1a2165a149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15630e1751e3b2dffde567b93eacc00"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae15630e1751e3b2dffde567b93eacc00"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#ae15630e1751e3b2dffde567b93eacc00">elem_by_elem_multiply</a> (const MatrixType1 &amp;m1, const MatrixType2 &amp;m2)</td></tr>
<tr class="separator:ae15630e1751e3b2dffde567b93eacc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0d9eb480ec17e1a52ed060b4d45b78"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ade0d9eb480ec17e1a52ed060b4d45b78"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#ade0d9eb480ec17e1a52ed060b4d45b78">elem_by_elem_divide</a> (const MatrixType1 &amp;m1, const MatrixType2 &amp;m2)</td></tr>
<tr class="separator:ade0d9eb480ec17e1a52ed060b4d45b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a344114e97294faa9ba9cf3b2f047b477"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a344114e97294faa9ba9cf3b2f047b477"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a344114e97294faa9ba9cf3b2f047b477">elem_by_elem_pow</a> (const MatrixType1 &amp;base, const MatrixType2 &amp;exponent)</td></tr>
<tr class="separator:a344114e97294faa9ba9cf3b2f047b477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64186b53e1042cb11c40599fe839233c"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a64186b53e1042cb11c40599fe839233c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a64186b53e1042cb11c40599fe839233c">min</a> (const MatrixType1 &amp;m1, const MatrixType2 &amp;m2)</td></tr>
<tr class="separator:a64186b53e1042cb11c40599fe839233c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13bf319e6670370563afdf22c048ca5"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab13bf319e6670370563afdf22c048ca5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#ab13bf319e6670370563afdf22c048ca5">max</a> (const MatrixType1 &amp;m1, const MatrixType2 &amp;m2)</td></tr>
<tr class="separator:ab13bf319e6670370563afdf22c048ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90966cd3b98a349c315aba4643a517df"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a90966cd3b98a349c315aba4643a517df"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a90966cd3b98a349c315aba4643a517df">operator-</a> (const MatrixType &amp;m)</td></tr>
<tr class="separator:a90966cd3b98a349c315aba4643a517df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2b173038af9a36bd276324229a4705"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1f2b173038af9a36bd276324229a4705"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a1f2b173038af9a36bd276324229a4705">sign</a> (const MatrixType &amp;m)</td></tr>
<tr class="separator:a1f2b173038af9a36bd276324229a4705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a3ff6d512e1c18f969d985410a3a85"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a78a3ff6d512e1c18f969d985410a3a85"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a78a3ff6d512e1c18f969d985410a3a85">abs</a> (const MatrixType &amp;m)</td></tr>
<tr class="separator:a78a3ff6d512e1c18f969d985410a3a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29fe91697a2200da66ae63d1ce0864f"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af29fe91697a2200da66ae63d1ce0864f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#af29fe91697a2200da66ae63d1ce0864f">sqrt</a> (const MatrixType &amp;m)</td></tr>
<tr class="separator:af29fe91697a2200da66ae63d1ce0864f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1487dc768908856dcdda2aa9628cea7b"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1487dc768908856dcdda2aa9628cea7b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a1487dc768908856dcdda2aa9628cea7b">exp</a> (const MatrixType &amp;m)</td></tr>
<tr class="separator:a1487dc768908856dcdda2aa9628cea7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3dc11d4549f5d4597dc7c0e3d0e0e57"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae3dc11d4549f5d4597dc7c0e3d0e0e57"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#ae3dc11d4549f5d4597dc7c0e3d0e0e57">exp2</a> (const MatrixType &amp;m)</td></tr>
<tr class="separator:ae3dc11d4549f5d4597dc7c0e3d0e0e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464d2498c6c6db5486ca8e854cd69b8b"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a464d2498c6c6db5486ca8e854cd69b8b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a464d2498c6c6db5486ca8e854cd69b8b">fft_moving_window</a> (const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;data, Eigen::Matrix&lt; std::complex&lt; Scalar &gt;, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;result, const double window_duration_sec, const double sampling_period_sec, const int num_overlap_steps)</td></tr>
<tr class="memdesc:a464d2498c6c6db5486ca8e854cd69b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the moving FFT of a matrix.  <a href="namespaceLazyMatrix.html#a464d2498c6c6db5486ca8e854cd69b8b">More...</a><br /></td></tr>
<tr class="separator:a464d2498c6c6db5486ca8e854cd69b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2204f6c5bde479dc587a1f0a0a0b2d"><td class="memItemLeft" align="right" valign="top">fs::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a2f2204f6c5bde479dc587a1f0a0a0b2d">get_absolute_path_of_executable</a> ()</td></tr>
<tr class="memdesc:a2f2204f6c5bde479dc587a1f0a0a0b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the absolute path of the executable.  <a href="namespaceLazyMatrix.html#a2f2204f6c5bde479dc587a1f0a0a0b2d">More...</a><br /></td></tr>
<tr class="separator:a2f2204f6c5bde479dc587a1f0a0a0b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468888dced3b3b85673d6da7c479359c"><td class="memItemLeft" align="right" valign="top">fs::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a468888dced3b3b85673d6da7c479359c">get_absolute_path_of_executable_parent_directory</a> ()</td></tr>
<tr class="memdesc:a468888dced3b3b85673d6da7c479359c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the absolute directory path of the executable's parent directory.  <a href="namespaceLazyMatrix.html#a468888dced3b3b85673d6da7c479359c">More...</a><br /></td></tr>
<tr class="separator:a468888dced3b3b85673d6da7c479359c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4812b500a97d8901c1b9f982931e14d"><td class="memItemLeft" align="right" valign="top">fs::path&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#af4812b500a97d8901c1b9f982931e14d">create_file_with_specified_size_and_unique_name</a> (std::size_t desired_file_size, std::error_code &amp;file_creation_error, std::string filename_template=&quot;XXXXXX&quot;, const fs::path &amp;directory_where_file_will_reside=fs::temp_directory_path())</td></tr>
<tr class="memdesc:af4812b500a97d8901c1b9f982931e14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a file with a specified size and unique name based on a template in a specified directory.  <a href="namespaceLazyMatrix.html#af4812b500a97d8901c1b9f982931e14d">More...</a><br /></td></tr>
<tr class="separator:af4812b500a97d8901c1b9f982931e14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1540e15d218ea9da477b1bddbcbacd9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; fs::path &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#aa1540e15d218ea9da477b1bddbcbacd9">list_files_matching_name</a> (const fs::path &amp;directory, const std::string &amp;name_to_match)</td></tr>
<tr class="memdesc:aa1540e15d218ea9da477b1bddbcbacd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">List all files in a directory and subdirectories matching a specific name or pattern.  <a href="namespaceLazyMatrix.html#aa1540e15d218ea9da477b1bddbcbacd9">More...</a><br /></td></tr>
<tr class="separator:aa1540e15d218ea9da477b1bddbcbacd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f8b03f02854d30f23cd53b567f70f8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#aa3f8b03f02854d30f23cd53b567f70f8">create_gaussian_kernel</a> (uintptr_t kernel_size, double sigma)</td></tr>
<tr class="memdesc:aa3f8b03f02854d30f23cd53b567f70f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Gaussian kernel of a specified size.  <a href="namespaceLazyMatrix.html#aa3f8b03f02854d30f23cd53b567f70f8">More...</a><br /></td></tr>
<tr class="separator:aa3f8b03f02854d30f23cd53b567f70f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842c877ab98a01c54c32505e8994fc35"><td class="memTemplParams" colspan="2">template&lt;typename DataType &gt; </td></tr>
<tr class="memitem:a842c877ab98a01c54c32505e8994fc35"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a842c877ab98a01c54c32505e8994fc35">create_laplacian_kernel</a> ()</td></tr>
<tr class="memdesc:a842c877ab98a01c54c32505e8994fc35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Laplacian kernel.  <a href="namespaceLazyMatrix.html#a842c877ab98a01c54c32505e8994fc35">More...</a><br /></td></tr>
<tr class="separator:a842c877ab98a01c54c32505e8994fc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b68a739d329965703cec0b495f67d08"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7b68a739d329965703cec0b495f67d08"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a7b68a739d329965703cec0b495f67d08">filter</a> (const MatrixType1 &amp;source_matrix, const MatrixType2 &amp;filter_kernel)</td></tr>
<tr class="memdesc:a7b68a739d329965703cec0b495f67d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a filter kernel to a source matrix.  <a href="namespaceLazyMatrix.html#a7b68a739d329965703cec0b495f67d08">More...</a><br /></td></tr>
<tr class="separator:a7b68a739d329965703cec0b495f67d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e1509368e1618071336d32eaff2ed0"><td class="memTemplParams" colspan="2">template&lt;typename DataType &gt; </td></tr>
<tr class="memitem:a28e1509368e1618071336d32eaff2ed0"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a28e1509368e1618071336d32eaff2ed0">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classLazyMatrix_1_1Interval.html">Interval</a>&lt; DataType &gt; &amp;interval)</td></tr>
<tr class="separator:a28e1509368e1618071336d32eaff2ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9430a5c9dfa688733a8996fa3d9f08b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#af9430a5c9dfa688733a8996fa3d9f08b">does_memory_contain_mapped_matrix</a> (const char *memory_mapped_matrix, uintptr_t memory_size_in_bytes)</td></tr>
<tr class="memdesc:af9430a5c9dfa688733a8996fa3d9f08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given memory region contains a memory-mapped matrix.  <a href="namespaceLazyMatrix.html#af9430a5c9dfa688733a8996fa3d9f08b">More...</a><br /></td></tr>
<tr class="separator:af9430a5c9dfa688733a8996fa3d9f08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fdaa751064f37673573395b10b9bb15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a8fdaa751064f37673573395b10b9bb15">does_memory_contain_mapped_matrix3d</a> (const char *memory_mapped_matrix3d, uintptr_t memory_size_in_bytes)</td></tr>
<tr class="separator:a8fdaa751064f37673573395b10b9bb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba265586218e5fd2aae76df13f824738"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aba265586218e5fd2aae76df13f824738"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#aba265586218e5fd2aae76df13f824738">operator*</a> (const MatrixType1 &amp;m1, const MatrixType2 &amp;m2)</td></tr>
<tr class="memdesc:aba265586218e5fd2aae76df13f824738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs matrix multiplication between two matrices.  <a href="namespaceLazyMatrix.html#aba265586218e5fd2aae76df13f824738">More...</a><br /></td></tr>
<tr class="separator:aba265586218e5fd2aae76df13f824738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9be71022ab22289bac109a76a2a4ce"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9e9be71022ab22289bac109a76a2a4ce"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a9e9be71022ab22289bac109a76a2a4ce">simple_moving_average_of_rows</a> (const MatrixType &amp;m1, int64_t number_of_data_points_to_average)</td></tr>
<tr class="separator:a9e9be71022ab22289bac109a76a2a4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f6d85eded6a2e0d001372717f70391"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a18f6d85eded6a2e0d001372717f70391"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a18f6d85eded6a2e0d001372717f70391">simple_moving_average_of_columns</a> (const MatrixType &amp;m1, int64_t number_of_data_points_to_average)</td></tr>
<tr class="separator:a18f6d85eded6a2e0d001372717f70391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e4b2ca8fc0a83ef04641067d1db2f1"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename DataType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab1e4b2ca8fc0a83ef04641067d1db2f1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#ab1e4b2ca8fc0a83ef04641067d1db2f1">pad_matrix</a> (const MatrixType &amp;m, uintptr_t padded_rows, uintptr_t padded_columns, const DataType &amp;constant_value_for_padding)</td></tr>
<tr class="separator:ab1e4b2ca8fc0a83ef04641067d1db2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d86e7aefcdf8c692b48970905894c48"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename DataType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2d86e7aefcdf8c692b48970905894c48"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a2d86e7aefcdf8c692b48970905894c48">pad_matrix_view</a> (MatrixType &amp;m, uintptr_t padded_rows, uintptr_t padded_columns, const DataType &amp;constant_value_for_padding)</td></tr>
<tr class="separator:a2d86e7aefcdf8c692b48970905894c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71c2a2d595f0ed582efdef1cb3ba779"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af71c2a2d595f0ed582efdef1cb3ba779"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#af71c2a2d595f0ed582efdef1cb3ba779">wrap_matrix</a> (MatrixType &amp;matrix)</td></tr>
<tr class="memdesc:af71c2a2d595f0ed582efdef1cb3ba779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a matrix in a <a class="el" href="classLazyMatrix_1_1PolymorphicMatrixWrapper.html" title="Wrapper class that provides a polymorphic interface to a given matrix type.">PolymorphicMatrixWrapper</a> and returns a shared pointer to <a class="el" href="classLazyMatrix_1_1PolymorphicMatrix.html" title="Base class providing a polymorphic interface for matrix-like data.">PolymorphicMatrix</a>.  <a href="namespaceLazyMatrix.html#af71c2a2d595f0ed582efdef1cb3ba779">More...</a><br /></td></tr>
<tr class="separator:af71c2a2d595f0ed582efdef1cb3ba779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038becb75eae0652944432579f77e0ef"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix3d.html">is_type_a_matrix3d</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a038becb75eae0652944432579f77e0ef"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a038becb75eae0652944432579f77e0ef">wrap_matrix3d</a> (MatrixType &amp;matrix)</td></tr>
<tr class="memdesc:a038becb75eae0652944432579f77e0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps a matrix in a <a class="el" href="classLazyMatrix_1_1PolymorphicMatrixWrapper3D.html" title="Wrapper class that provides a polymorphic interface to a given 3d-matrix type.">PolymorphicMatrixWrapper3D</a> and returns a shared pointer to <a class="el" href="classLazyMatrix_1_1PolymorphicMatrix3D.html" title="Base class providing a polymorphic interface for 3d-matrix-like data.">PolymorphicMatrix3D</a>.  <a href="namespaceLazyMatrix.html#a038becb75eae0652944432579f77e0ef">More...</a><br /></td></tr>
<tr class="separator:a038becb75eae0652944432579f77e0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6368fd31c623cd3f20c4297cff027d3f"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6368fd31c623cd3f20c4297cff027d3f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a6368fd31c623cd3f20c4297cff027d3f">bind_matrix_view</a> (pybind11::module &amp;m, const char *name)</td></tr>
<tr class="memdesc:a6368fd31c623cd3f20c4297cff027d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind matrix class for view access in Python.  <a href="namespaceLazyMatrix.html#a6368fd31c623cd3f20c4297cff027d3f">More...</a><br /></td></tr>
<tr class="separator:a6368fd31c623cd3f20c4297cff027d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017db20c808c143fb1ec4c597a300723"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a017db20c808c143fb1ec4c597a300723"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a017db20c808c143fb1ec4c597a300723">bind_matrix</a> (pybind11::module &amp;m, const char *name)</td></tr>
<tr class="memdesc:a017db20c808c143fb1ec4c597a300723"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind matrix class for const access in Python.  <a href="namespaceLazyMatrix.html#a017db20c808c143fb1ec4c597a300723">More...</a><br /></td></tr>
<tr class="separator:a017db20c808c143fb1ec4c597a300723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3b8eb5a1ea870f4390f47758939c5d"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abc3b8eb5a1ea870f4390f47758939c5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#abc3b8eb5a1ea870f4390f47758939c5d">bind_matrix_storage</a> (pybind11::module &amp;m, const char *name)</td></tr>
<tr class="memdesc:abc3b8eb5a1ea870f4390f47758939c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind matrix class with storage constructor in Python.  <a href="namespaceLazyMatrix.html#abc3b8eb5a1ea870f4390f47758939c5d">More...</a><br /></td></tr>
<tr class="separator:abc3b8eb5a1ea870f4390f47758939c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973fa91b38ea51a296fa988b0fc133a9"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename... Matrices&gt; </td></tr>
<tr class="memitem:a973fa91b38ea51a296fa988b0fc133a9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, MatrixType &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a973fa91b38ea51a296fa988b0fc133a9">create_named_matrix_vector</a> (const std::string &amp;prefix, MatrixType &amp;first, Matrices &amp;... rest)</td></tr>
<tr class="memdesc:a973fa91b38ea51a296fa988b0fc133a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a vector of named matrix references suitable for Python script execution.  <a href="namespaceLazyMatrix.html#a973fa91b38ea51a296fa988b0fc133a9">More...</a><br /></td></tr>
<tr class="separator:a973fa91b38ea51a296fa988b0fc133a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bc9be9edfd4f0622572ef578ac98d9"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:af8bc9be9edfd4f0622572ef578ac98d9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, MatrixType &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#af8bc9be9edfd4f0622572ef578ac98d9">create_named_matrix_vector</a> (const std::string &amp;prefix)</td></tr>
<tr class="memdesc:af8bc9be9edfd4f0622572ef578ac98d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty vector of named matrix references.  <a href="namespaceLazyMatrix.html#af8bc9be9edfd4f0622572ef578ac98d9">More...</a><br /></td></tr>
<tr class="separator:af8bc9be9edfd4f0622572ef578ac98d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11194858277f5ee840a2b83a5af815cf"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a11194858277f5ee840a2b83a5af815cf"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a11194858277f5ee840a2b83a5af815cf">execute_python_script</a> (const std::vector&lt; MatrixType &gt; &amp;input_matrices, const std::vector&lt; MatrixType &gt; &amp;output_matrices, const std::string &amp;script, const std::string &amp;module_name)</td></tr>
<tr class="memdesc:a11194858277f5ee840a2b83a5af815cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a Python script with given input and output matrices.  <a href="namespaceLazyMatrix.html#a11194858277f5ee840a2b83a5af815cf">More...</a><br /></td></tr>
<tr class="separator:a11194858277f5ee840a2b83a5af815cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0322c2e9962f08ada36f9e784ccfe01"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab0322c2e9962f08ada36f9e784ccfe01"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#ab0322c2e9962f08ada36f9e784ccfe01">reverse</a> (const MatrixType &amp;m, bool should_rows_be_reversed, bool should_columns_be_reversed)</td></tr>
<tr class="memdesc:ab0322c2e9962f08ada36f9e784ccfe01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create a <a class="el" href="structLazyMatrix_1_1Reverse.html" title="A class that provides a non-modifiable reversed view of a matrix.">Reverse</a> object from a matrix expression.  <a href="namespaceLazyMatrix.html#ab0322c2e9962f08ada36f9e784ccfe01">More...</a><br /></td></tr>
<tr class="separator:ab0322c2e9962f08ada36f9e784ccfe01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb270622d381e56b396864d06c2a715"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adeb270622d381e56b396864d06c2a715"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#adeb270622d381e56b396864d06c2a715">reverse_view</a> (MatrixType &amp;m, bool should_rows_be_reversed, bool should_columns_be_reversed)</td></tr>
<tr class="memdesc:adeb270622d381e56b396864d06c2a715"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create a <a class="el" href="structLazyMatrix_1_1ReverseView.html" title="A class that provides a reversed view of a matrix.">ReverseView</a> from a matrix expression.  <a href="namespaceLazyMatrix.html#adeb270622d381e56b396864d06c2a715">More...</a><br /></td></tr>
<tr class="separator:adeb270622d381e56b396864d06c2a715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8d4d4f34f6faed552e8d8930b12a67"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afc8d4d4f34f6faed552e8d8930b12a67"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#afc8d4d4f34f6faed552e8d8930b12a67">roi</a> (const MatrixType &amp;m1, int row1, int column1, int row2, int column2)</td></tr>
<tr class="separator:afc8d4d4f34f6faed552e8d8930b12a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0dcb34878fa9ade0f0e7026cd0f809"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adc0dcb34878fa9ade0f0e7026cd0f809"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#adc0dcb34878fa9ade0f0e7026cd0f809">roi_view</a> (MatrixType &amp;m1, int64_t row1, int64_t column1, int64_t row2, int64_t column2)</td></tr>
<tr class="separator:adc0dcb34878fa9ade0f0e7026cd0f809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac13368c99f51cb312c4eb031338a96"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8ac13368c99f51cb312c4eb031338a96"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a8ac13368c99f51cb312c4eb031338a96">select_a_single_row</a> (const MatrixType &amp;m, int64_t selected_row)</td></tr>
<tr class="separator:a8ac13368c99f51cb312c4eb031338a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505fd6c71a83582a83c331c6d675e634"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a505fd6c71a83582a83c331c6d675e634"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a505fd6c71a83582a83c331c6d675e634">select_a_single_column</a> (const MatrixType &amp;m, int64_t selected_column)</td></tr>
<tr class="separator:a505fd6c71a83582a83c331c6d675e634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6fa9752234c6e8258fae6e5d2b0a98"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4e6fa9752234c6e8258fae6e5d2b0a98"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a4e6fa9752234c6e8258fae6e5d2b0a98">select_rows</a> (const MatrixType &amp;m, const std::vector&lt; int64_t &gt; &amp;selected_rows)</td></tr>
<tr class="separator:a4e6fa9752234c6e8258fae6e5d2b0a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5545aa573feba6d945b2dd52039252"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1e5545aa573feba6d945b2dd52039252"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a1e5545aa573feba6d945b2dd52039252">select_columns</a> (const MatrixType &amp;m, const std::vector&lt; int64_t &gt; &amp;selected_columns)</td></tr>
<tr class="separator:a1e5545aa573feba6d945b2dd52039252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ccd78dc46b2d4e0ff4add218737d74f"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3ccd78dc46b2d4e0ff4add218737d74f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a3ccd78dc46b2d4e0ff4add218737d74f">select_rows_and_columns</a> (const MatrixType &amp;m, const std::vector&lt; int64_t &gt; &amp;selected_rows, const std::vector&lt; int64_t &gt; &amp;selected_columns)</td></tr>
<tr class="separator:a3ccd78dc46b2d4e0ff4add218737d74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e315488009fc272c86dd82df82e943"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a22e315488009fc272c86dd82df82e943"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a22e315488009fc272c86dd82df82e943">select_a_single_row_view</a> (MatrixType &amp;m, int64_t selected_row)</td></tr>
<tr class="separator:a22e315488009fc272c86dd82df82e943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9e10f8127b7d32103c43f47e4dd3d6"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afd9e10f8127b7d32103c43f47e4dd3d6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#afd9e10f8127b7d32103c43f47e4dd3d6">select_a_single_column_view</a> (MatrixType &amp;m, int64_t selected_column)</td></tr>
<tr class="separator:afd9e10f8127b7d32103c43f47e4dd3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd5977f6bb47f1f1f35bb97b2f65958"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acdd5977f6bb47f1f1f35bb97b2f65958"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#acdd5977f6bb47f1f1f35bb97b2f65958">select_rows_view</a> (MatrixType &amp;m, const std::vector&lt; int64_t &gt; &amp;selected_rows)</td></tr>
<tr class="separator:acdd5977f6bb47f1f1f35bb97b2f65958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b1a8097f36f98dda3d55eda49b5b97"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a13b1a8097f36f98dda3d55eda49b5b97"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a13b1a8097f36f98dda3d55eda49b5b97">select_columns_view</a> (MatrixType &amp;m, const std::vector&lt; int64_t &gt; &amp;selected_columns)</td></tr>
<tr class="separator:a13b1a8097f36f98dda3d55eda49b5b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb51107cd940a41240794cd28abc035"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abdb51107cd940a41240794cd28abc035"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#abdb51107cd940a41240794cd28abc035">select_rows_and_columns_view</a> (MatrixType &amp;m, const std::vector&lt; int64_t &gt; &amp;selected_rows, const std::vector&lt; int64_t &gt; &amp;selected_columns)</td></tr>
<tr class="separator:abdb51107cd940a41240794cd28abc035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85cc8964cfece59793e3c18b5e82601"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab85cc8964cfece59793e3c18b5e82601"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#ab85cc8964cfece59793e3c18b5e82601">shuffle</a> (const MatrixType &amp;m, bool should_rows_be_reversed, bool should_columns_be_reversed)</td></tr>
<tr class="separator:ab85cc8964cfece59793e3c18b5e82601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addaccc121e5250d7353ab9dd86816805"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:addaccc121e5250d7353ab9dd86816805"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#addaccc121e5250d7353ab9dd86816805">shuffle_view</a> (MatrixType &amp;m, bool should_rows_be_reversed, bool should_columns_be_reversed)</td></tr>
<tr class="separator:addaccc121e5250d7353ab9dd86816805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ffdde83316599a2cb05990ea23fe12"><td class="memTemplParams" colspan="2">template&lt;typename SimpleDataType &gt; </td></tr>
<tr class="memitem:a75ffdde83316599a2cb05990ea23fe12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLazyMatrix_1_1SimpleData2DMatrixWrapper.html">SimpleData2DMatrixWrapper</a>&lt; SimpleDataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a75ffdde83316599a2cb05990ea23fe12">wrap_in_matrix</a> (const SimpleDataType &amp;value)</td></tr>
<tr class="memdesc:a75ffdde83316599a2cb05990ea23fe12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 2d-matrix-like wrapper for a simple data value.  <a href="namespaceLazyMatrix.html#a75ffdde83316599a2cb05990ea23fe12">More...</a><br /></td></tr>
<tr class="separator:a75ffdde83316599a2cb05990ea23fe12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5da7f79d1ca021a844d3b6c03b85428"><td class="memTemplParams" colspan="2">template&lt;typename SimpleDataType &gt; </td></tr>
<tr class="memitem:aa5da7f79d1ca021a844d3b6c03b85428"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLazyMatrix_1_1SimpleData3DMatrixWrapper.html">SimpleData3DMatrixWrapper</a>&lt; SimpleDataType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#aa5da7f79d1ca021a844d3b6c03b85428">wrap_in_matrix</a> (const SimpleDataType &amp;value)</td></tr>
<tr class="memdesc:aa5da7f79d1ca021a844d3b6c03b85428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a 3d-matrix-like wrapper for a simple data value.  <a href="namespaceLazyMatrix.html#aa5da7f79d1ca021a844d3b6c03b85428">More...</a><br /></td></tr>
<tr class="separator:aa5da7f79d1ca021a844d3b6c03b85428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfca7638e9e4b5310090b56b8c25bcd4"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acfca7638e9e4b5310090b56b8c25bcd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#acfca7638e9e4b5310090b56b8c25bcd4">get_sorted_indices</a> (const MatrixType &amp;matrix, int64_t index, bool sort_by_row, std::vector&lt; int64_t &gt; &amp;sorted_indices)</td></tr>
<tr class="memdesc:acfca7638e9e4b5310090b56b8c25bcd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies a given vector to contain sorted indices based on a matrix row or column.  <a href="namespaceLazyMatrix.html#acfca7638e9e4b5310090b56b8c25bcd4">More...</a><br /></td></tr>
<tr class="separator:acfca7638e9e4b5310090b56b8c25bcd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab098b2d65f4d9289d13b38951dd5e68f"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab098b2d65f4d9289d13b38951dd5e68f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#ab098b2d65f4d9289d13b38951dd5e68f">sorted_matrix_view</a> (MatrixType &amp;m, int64_t index_of_row_or_column_to_use_to_sort, bool sort_by_rows)</td></tr>
<tr class="separator:ab098b2d65f4d9289d13b38951dd5e68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c278e5cd0c4fe5b331e93f78aea02b"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a94c278e5cd0c4fe5b331e93f78aea02b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a94c278e5cd0c4fe5b331e93f78aea02b">sorted_matrix</a> (const MatrixType &amp;m, int64_t index_of_row_or_column_to_use_to_sort, bool sort_by_rows)</td></tr>
<tr class="separator:a94c278e5cd0c4fe5b331e93f78aea02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97384febee24becf2e685e3853d626a"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:af97384febee24becf2e685e3853d626a"><td class="memTemplItemLeft" align="right" valign="top">MatrixType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#af97384febee24becf2e685e3853d626a">trim_matrix</a> (const MatrixType &amp;matrix, int rows, int cols)</td></tr>
<tr class="memdesc:af97384febee24becf2e685e3853d626a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims a matrix to the specified size.  <a href="namespaceLazyMatrix.html#af97384febee24becf2e685e3853d626a">More...</a><br /></td></tr>
<tr class="separator:af97384febee24becf2e685e3853d626a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b723cc31bd0c1ca561c409a77bb5a0"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac1b723cc31bd0c1ca561c409a77bb5a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#ac1b723cc31bd0c1ca561c409a77bb5a0">strassen_split</a> (const MatrixType1 &amp;matrix, MatrixType2 &amp;a11, MatrixType2 &amp;a12, MatrixType2 &amp;a21, MatrixType2 &amp;a22)</td></tr>
<tr class="memdesc:ac1b723cc31bd0c1ca561c409a77bb5a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a matrix into four equal submatrices.  <a href="namespaceLazyMatrix.html#ac1b723cc31bd0c1ca561c409a77bb5a0">More...</a><br /></td></tr>
<tr class="separator:ac1b723cc31bd0c1ca561c409a77bb5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47690be30af41c6491a2074ac725294a"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a47690be30af41c6491a2074ac725294a"><td class="memTemplItemLeft" align="right" valign="top">MatrixType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a47690be30af41c6491a2074ac725294a">strassen_combine</a> (const MatrixType &amp;a11, const MatrixType &amp;a12, const MatrixType &amp;a21, const MatrixType &amp;a22)</td></tr>
<tr class="memdesc:a47690be30af41c6491a2074ac725294a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines four submatrices into a single matrix.  <a href="namespaceLazyMatrix.html#a47690be30af41c6491a2074ac725294a">More...</a><br /></td></tr>
<tr class="separator:a47690be30af41c6491a2074ac725294a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af712f793c89d5e73672e453bda1297"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6af712f793c89d5e73672e453bda1297"><td class="memTemplItemLeft" align="right" valign="top">MatrixType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a6af712f793c89d5e73672e453bda1297">strassen_add</a> (const MatrixType &amp;a, const MatrixType &amp;b)</td></tr>
<tr class="memdesc:a6af712f793c89d5e73672e453bda1297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds two matrices.  <a href="namespaceLazyMatrix.html#a6af712f793c89d5e73672e453bda1297">More...</a><br /></td></tr>
<tr class="separator:a6af712f793c89d5e73672e453bda1297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6238a2b46de481cac9454d09177c9ecf"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6238a2b46de481cac9454d09177c9ecf"><td class="memTemplItemLeft" align="right" valign="top">MatrixType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a6238a2b46de481cac9454d09177c9ecf">strassen_subtract</a> (const MatrixType &amp;a, const MatrixType &amp;b)</td></tr>
<tr class="memdesc:a6238a2b46de481cac9454d09177c9ecf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts one matrix from another.  <a href="namespaceLazyMatrix.html#a6238a2b46de481cac9454d09177c9ecf">More...</a><br /></td></tr>
<tr class="separator:a6238a2b46de481cac9454d09177c9ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0565e3e4beb3355aa4057c3494d01615"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0565e3e4beb3355aa4057c3494d01615"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a0565e3e4beb3355aa4057c3494d01615">strassen_multiply_recursive</a> (const MatrixType &amp;a, const MatrixType &amp;b)</td></tr>
<tr class="memdesc:a0565e3e4beb3355aa4057c3494d01615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively multiplies two matrices using the Strassen algorithm.  <a href="namespaceLazyMatrix.html#a0565e3e4beb3355aa4057c3494d01615">More...</a><br /></td></tr>
<tr class="separator:a0565e3e4beb3355aa4057c3494d01615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c45411aad33d12c28562a38dc0e542"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a66c45411aad33d12c28562a38dc0e542"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a66c45411aad33d12c28562a38dc0e542">strassen_matrix_multiply</a> (const MatrixType1 &amp;a, const MatrixType2 &amp;b)</td></tr>
<tr class="memdesc:a66c45411aad33d12c28562a38dc0e542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs matrix multiplication using the Strassen algorithm.  <a href="namespaceLazyMatrix.html#a66c45411aad33d12c28562a38dc0e542">More...</a><br /></td></tr>
<tr class="separator:a66c45411aad33d12c28562a38dc0e542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8b0ee561b071e49c1b95a78ff917ba"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adb8b0ee561b071e49c1b95a78ff917ba"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#adb8b0ee561b071e49c1b95a78ff917ba">transpose</a> (const MatrixType &amp;m)</td></tr>
<tr class="memdesc:adb8b0ee561b071e49c1b95a78ff917ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create a <a class="el" href="classLazyMatrix_1_1Transpose.html" title="A class that provides a read-only transposed view of a matrix.">Transpose</a> from a matrix expression.  <a href="namespaceLazyMatrix.html#adb8b0ee561b071e49c1b95a78ff917ba">More...</a><br /></td></tr>
<tr class="separator:adb8b0ee561b071e49c1b95a78ff917ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4fb5b5932ae2e59b0a24f8cd82828a"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1e4fb5b5932ae2e59b0a24f8cd82828a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a1e4fb5b5932ae2e59b0a24f8cd82828a">transpose_view</a> (MatrixType &amp;m)</td></tr>
<tr class="memdesc:a1e4fb5b5932ae2e59b0a24f8cd82828a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to create a <a class="el" href="classLazyMatrix_1_1TransposeView.html" title="A view class that provides a transposed view of a matrix.">TransposeView</a> from a matrix expression.  <a href="namespaceLazyMatrix.html#a1e4fb5b5932ae2e59b0a24f8cd82828a">More...</a><br /></td></tr>
<tr class="separator:a1e4fb5b5932ae2e59b0a24f8cd82828a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae5f7e3530431416e7b92f68c895c0b3b"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#ae5f7e3530431416e7b92f68c895c0b3b">matrix_header_byte_sequence</a> = &quot;::---begin---::\n&quot;</td></tr>
<tr class="separator:ae5f7e3530431416e7b92f68c895c0b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90114cc2fd66533f72fb96dd5fff14f7"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a90114cc2fd66533f72fb96dd5fff14f7">matrix_footer_byte_sequence</a> = &quot;::----end----::\n&quot;</td></tr>
<tr class="separator:a90114cc2fd66533f72fb96dd5fff14f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a796191179d49aed39ac92eb89cc8d1ea"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#a796191179d49aed39ac92eb89cc8d1ea">matrix3d_header_byte_sequence</a> = &quot;---begin_3d_---\n&quot;</td></tr>
<tr class="separator:a796191179d49aed39ac92eb89cc8d1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae858a6ae5c52bcd785b123e3b09e55e5"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceLazyMatrix.html#ae858a6ae5c52bcd785b123e3b09e55e5">matrix3d_footer_byte_sequence</a> = &quot;:---end_3d_---:\n&quot;</td></tr>
<tr class="separator:ae858a6ae5c52bcd785b123e3b09e55e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a76f0e21840057cc6abe605c5e3528f56" name="a76f0e21840057cc6abe605c5e3528f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f0e21840057cc6abe605c5e3528f56">&#9670;&nbsp;</a></span>Data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceLazyMatrix.html#a76f0e21840057cc6abe605c5e3528f56">LazyMatrix::Data</a> = typedef <a class="el" href="classLazyMatrix_1_1PolymorphicMatrix.html">PolymorphicMatrix</a>&lt;DataType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acc49dc6be2c966f9695d998cb07aca2b" name="acc49dc6be2c966f9695d998cb07aca2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc49dc6be2c966f9695d998cb07aca2b">&#9670;&nbsp;</a></span>Data3D</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceLazyMatrix.html#acc49dc6be2c966f9695d998cb07aca2b">LazyMatrix::Data3D</a> = typedef <a class="el" href="classLazyMatrix_1_1PolymorphicMatrix3D.html">PolymorphicMatrix3D</a>&lt;DataType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02a315430f93fceaf3bb61b6688d8e6a" name="a02a315430f93fceaf3bb61b6688d8e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a315430f93fceaf3bb61b6688d8e6a">&#9670;&nbsp;</a></span>SpecializedData</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceLazyMatrix.html#a02a315430f93fceaf3bb61b6688d8e6a">LazyMatrix::SpecializedData</a> = typedef <a class="el" href="classLazyMatrix_1_1PolymorphicMatrixWrapper.html">PolymorphicMatrixWrapper</a>&lt;MatrixType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e215196948db549e143041b028c5c87" name="a1e215196948db549e143041b028c5c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e215196948db549e143041b028c5c87">&#9670;&nbsp;</a></span>SpecializedData3D</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceLazyMatrix.html#a1e215196948db549e143041b028c5c87">LazyMatrix::SpecializedData3D</a> = typedef <a class="el" href="classLazyMatrix_1_1PolymorphicMatrixWrapper3D.html">PolymorphicMatrixWrapper3D</a>&lt;MatrixType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a78a3ff6d512e1c18f969d985410a3a85" name="a78a3ff6d512e1c18f969d985410a3a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a3ff6d512e1c18f969d985410a3a85">&#9670;&nbsp;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::abs </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1f9cbd0c333a1f648cf02ba3be18668" name="aa1f9cbd0c333a1f648cf02ba3be18668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f9cbd0c333a1f648cf02ba3be18668">&#9670;&nbsp;</a></span>augment_by_columns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::augment_by_columns </td>
          <td>(</td>
          <td class="paramtype">const MatrixType1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to augment two matrices by columns. </p>
<p >This function takes two matrix expressions and creates a new matrix that represents the augmentation of these matrices by columns.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType1</td><td>Type of the left side matrix. </td></tr>
    <tr><td class="paramname">MatrixType2</td><td>Type of the right side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>Reference to the left side matrix. </td></tr>
    <tr><td class="paramname">m2</td><td>Reference to the right side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="structLazyMatrix_1_1AugmentColumns.html" title="Augments two matrices by columns to create a new matrix.">AugmentColumns</a> object representing the augmented matrix. </dd></dl>

</div>
</div>
<a id="a1aa1103c90a5e411bd0a7d990d20c1e8" name="a1aa1103c90a5e411bd0a7d990d20c1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa1103c90a5e411bd0a7d990d20c1e8">&#9670;&nbsp;</a></span>augment_by_columns_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::augment_by_columns_view </td>
          <td>(</td>
          <td class="paramtype">MatrixType1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to augment two matrices by columns. </p>
<p >This function takes two matrix expressions and creates a view that represents the augmentation of these matrices by columns.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType1</td><td>Type of the left side matrix. </td></tr>
    <tr><td class="paramname">MatrixType2</td><td>Type of the right side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>Reference to the left side matrix. </td></tr>
    <tr><td class="paramname">m2</td><td>Reference to the right side matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="structLazyMatrix_1_1AugmentColumnsView.html" title="Augments two matrices by columns to create a new matrix view.">AugmentColumnsView</a> object representing the augmented matrix. </dd></dl>

</div>
</div>
<a id="a5b18c3470ab6e918c3b05eca61fa150c" name="a5b18c3470ab6e918c3b05eca61fa150c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b18c3470ab6e918c3b05eca61fa150c">&#9670;&nbsp;</a></span>augment_by_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::augment_by_rows </td>
          <td>(</td>
          <td class="paramtype">const MatrixType1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to augment two matrices by rows. </p>
<p >This function takes two matrix expressions and creates a new matrix that represents the augmentation of these matrices by rows.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType1</td><td>Type of the upper matrix. </td></tr>
    <tr><td class="paramname">MatrixType2</td><td>Type of the lower matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>Reference to the upper matrix. </td></tr>
    <tr><td class="paramname">m2</td><td>Reference to the lower matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="structLazyMatrix_1_1AugmentRows.html" title="Augments two matrices by rows to create a new matrix.">AugmentRows</a> object representing the augmented matrix. </dd></dl>

</div>
</div>
<a id="a76342b165d4a5b24bfb578fdf3bc0e5a" name="a76342b165d4a5b24bfb578fdf3bc0e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76342b165d4a5b24bfb578fdf3bc0e5a">&#9670;&nbsp;</a></span>augment_by_rows_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::augment_by_rows_view </td>
          <td>(</td>
          <td class="paramtype">MatrixType1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to augment two matrices by rows as a view. </p>
<p >This function takes two matrix expressions and creates a new matrix view that represents the augmentation of these matrices by rows without copying the data.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType1</td><td>Type of the upper matrix. </td></tr>
    <tr><td class="paramname">MatrixType2</td><td>Type of the lower matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>Reference to the upper matrix. </td></tr>
    <tr><td class="paramname">m2</td><td>Reference to the lower matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="structLazyMatrix_1_1AugmentRowsView.html" title="Augments two matrices by rows to create a new matrix view.">AugmentRowsView</a> object representing the augmented matrix view. </dd></dl>

</div>
</div>
<a id="a017db20c808c143fb1ec4c597a300723" name="a017db20c808c143fb1ec4c597a300723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017db20c808c143fb1ec4c597a300723">&#9670;&nbsp;</a></span>bind_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LazyMatrix::bind_matrix </td>
          <td>(</td>
          <td class="paramtype">pybind11::module &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind matrix class for const access in Python. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>The matrix type to bind. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The pybind11 module. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the matrix in Python. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc3b8eb5a1ea870f4390f47758939c5d" name="abc3b8eb5a1ea870f4390f47758939c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3b8eb5a1ea870f4390f47758939c5d">&#9670;&nbsp;</a></span>bind_matrix_storage()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LazyMatrix::bind_matrix_storage </td>
          <td>(</td>
          <td class="paramtype">pybind11::module &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind matrix class with storage constructor in Python. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>The matrix type to bind. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The pybind11 module. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the matrix in Python. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6368fd31c623cd3f20c4297cff027d3f" name="a6368fd31c623cd3f20c4297cff027d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6368fd31c623cd3f20c4297cff027d3f">&#9670;&nbsp;</a></span>bind_matrix_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LazyMatrix::bind_matrix_view </td>
          <td>(</td>
          <td class="paramtype">pybind11::module &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind matrix class for view access in Python. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>The matrix type to bind. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The pybind11 module. </td></tr>
    <tr><td class="paramname">name</td><td>The name of the matrix in Python. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addf0808376958b27dc1418d74e66f1b9" name="addf0808376958b27dc1418d74e66f1b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf0808376958b27dc1418d74e66f1b9">&#9670;&nbsp;</a></span>constant_border()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename DataType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::constant_border </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>constant_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ebfb0a26e62bf86fefdaa0fa04b7cff" name="a1ebfb0a26e62bf86fefdaa0fa04b7cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ebfb0a26e62bf86fefdaa0fa04b7cff">&#9670;&nbsp;</a></span>constant_border_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename DataType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::constant_border_view </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>constant_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af4812b500a97d8901c1b9f982931e14d" name="af4812b500a97d8901c1b9f982931e14d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4812b500a97d8901c1b9f982931e14d">&#9670;&nbsp;</a></span>create_file_with_specified_size_and_unique_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">fs::path LazyMatrix::create_file_with_specified_size_and_unique_name </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>desired_file_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::error_code &amp;&#160;</td>
          <td class="paramname"><em>file_creation_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename_template</em> = <code>&quot;XXXXXX&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>directory_where_file_will_reside</em> = <code>fs::temp_directory_path()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a file with a specified size and unique name based on a template in a specified directory. </p>
<p >This function generates a unique filename, creates the file with the specified size, and returns an error code. It handles the creation of the file differently on Windows and Linux.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desired_file_size</td><td>Size of the file to be created. </td></tr>
    <tr><td class="paramname">file_creation_error</td><td>Error code for file creation. </td></tr>
    <tr><td class="paramname">filename_template</td><td>Template for the filename, should end with "XXXXXX". </td></tr>
    <tr><td class="paramname">directory_where_file_will_reside</td><td>Directory where the file will reside. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>fs::path Path to the created file. </dd></dl>

</div>
</div>
<a id="aa3f8b03f02854d30f23cd53b567f70f8" name="aa3f8b03f02854d30f23cd53b567f70f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3f8b03f02854d30f23cd53b567f70f8">&#9670;&nbsp;</a></span>create_gaussian_kernel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::create_gaussian_kernel </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>kernel_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a Gaussian kernel of a specified size. </p>
<p >This function generates a Gaussian kernel, which is useful for smoothing images. The Gaussian kernel is a square matrix with dimensions based on the specified kernel size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kernel_size</td><td>The size of the kernel (should be odd). </td></tr>
    <tr><td class="paramname">sigma</td><td>The standard deviation of the Gaussian distribution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix&lt;double&gt; A Gaussian kernel matrix. </dd></dl>

</div>
</div>
<a id="a842c877ab98a01c54c32505e8994fc35" name="a842c877ab98a01c54c32505e8994fc35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842c877ab98a01c54c32505e8994fc35">&#9670;&nbsp;</a></span>create_laplacian_kernel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::create_laplacian_kernel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a Laplacian kernel. </p>
<p >This function generates a Laplacian kernel, used for edge detection in images. The Laplacian kernel is a 3x3 matrix with specific values to highlight areas of rapid intensity change.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DataType</td><td>The data type of the matrix elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix&lt;DataType&gt; A Laplacian kernel matrix. </dd></dl>

</div>
</div>
<a id="af8bc9be9edfd4f0622572ef578ac98d9" name="af8bc9be9edfd4f0622572ef578ac98d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bc9be9edfd4f0622572ef578ac98d9">&#9670;&nbsp;</a></span>create_named_matrix_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::string, MatrixType &amp; &gt; &gt; LazyMatrix::create_named_matrix_vector </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an empty vector of named matrix references. </p>
<p >This overloaded function handles cases where no matrices are provided. It simply returns an empty vector. This is useful when you need to provide an empty vector of matrix references to a function or process.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>The type of the matrices, ensuring that only matrix types are used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>A string prefix for naming the matrices. This is not used but is kept for function signature consistency. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An empty vector of pairs of matrix names and matrix references. </dd></dl>

</div>
</div>
<a id="a973fa91b38ea51a296fa988b0fc133a9" name="a973fa91b38ea51a296fa988b0fc133a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973fa91b38ea51a296fa988b0fc133a9">&#9670;&nbsp;</a></span>create_named_matrix_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename... Matrices&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::string, MatrixType &amp; &gt; &gt; LazyMatrix::create_named_matrix_vector </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrices &amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a vector of named matrix references suitable for Python script execution. </p>
<p >This overloaded function handles cases where at least one matrix is provided. It generates a vector containing pairs of matrix names and references. The names are automatically assigned based on the provided prefix followed by a sequential index.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>The type of the matrices, ensuring that only matrix types are used. </td></tr>
    <tr><td class="paramname">Matrices</td><td>Variadic template to handle multiple matrix references. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>A string prefix for naming the matrices (e.g., "in" for input matrices). </td></tr>
    <tr><td class="paramname">first</td><td>The first matrix reference. </td></tr>
    <tr><td class="paramname">rest</td><td>The rest of the matrix references. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of pairs of matrix names and matrix references. </dd></dl>

</div>
</div>
<a id="a18a6a8179a7ea910a485250b9587c745" name="a18a6a8179a7ea910a485250b9587c745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a6a8179a7ea910a485250b9587c745">&#9670;&nbsp;</a></span>diff()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::diff </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>difference_direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af9430a5c9dfa688733a8996fa3d9f08b" name="af9430a5c9dfa688733a8996fa3d9f08b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9430a5c9dfa688733a8996fa3d9f08b">&#9670;&nbsp;</a></span>does_memory_contain_mapped_matrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LazyMatrix::does_memory_contain_mapped_matrix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>memory_mapped_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>memory_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if the given memory region contains a memory-mapped matrix. </p>
<p >It inspects the memory region to determine if it adheres to the layout and size requirements of a memory-mapped matrix, as specified by the <a class="el" href="structLazyMatrix_1_1MatrixHeader.html" title="Struct representing the header of a memory-mapped matrix.">MatrixHeader</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memory_mapped_matrix</td><td>Pointer to the start of the memory-mapped region. </td></tr>
    <tr><td class="paramname">memory_size_in_bytes</td><td>Size of the memory region in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the memory region contains a valid memory-mapped matrix. </dd>
<dd>
false If the memory region does not contain a valid memory-mapped matrix. </dd></dl>

</div>
</div>
<a id="a8fdaa751064f37673573395b10b9bb15" name="a8fdaa751064f37673573395b10b9bb15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fdaa751064f37673573395b10b9bb15">&#9670;&nbsp;</a></span>does_memory_contain_mapped_matrix3d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool LazyMatrix::does_memory_contain_mapped_matrix3d </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>memory_mapped_matrix3d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>memory_size_in_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ed31aad32043cbe8392de552602f6a0" name="a3ed31aad32043cbe8392de552602f6a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed31aad32043cbe8392de552602f6a0">&#9670;&nbsp;</a></span>downsample_lttb()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LazyMatrix::downsample_lttb </td>
          <td>(</td>
          <td class="paramtype">const MatrixType1 &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType2 &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>source_start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>source_end_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Downsampling a single row or column vector using the Largest Triangle Three Buckets (LTTB) algorithm. </p>
<p >This function applies the LTTB algorithm to downsample a single-dimensional data set (row or column vector). It is particularly useful in reducing the number of data points while preserving the visual shape of the data. The function allows specifying start and end indexes for flexible downsampling, including reverse or circular sampling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source vector (either row or column) containing the original data points. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination vector where the downsampled data will be stored. </td></tr>
    <tr><td class="paramname">source_start_index</td><td>The starting index in the source data for downsampling. </td></tr>
    <tr><td class="paramname">source_end_index</td><td>The ending index in the source data for downsampling.</td></tr>
  </table>
  </dd>
</dl>
<p>Example usage:</p><ul>
<li>Standard Downsampling: downsample_lttb(source, destination, 0, source.size() - 1);</li>
<li><a class="el" href="structLazyMatrix_1_1Reverse.html" title="A class that provides a non-modifiable reversed view of a matrix.">Reverse</a> Downsampling: downsample_lttb(source, destination, source.size() - 1, -1);</li>
<li>Circular Downsampling: downsample_lttb(source, destination, mid_point, mid_point - 1); where mid_point is some index in the middle of the source data. </li>
</ul>

</div>
</div>
<a id="a6785541359a9cee7b1b887451a15299e" name="a6785541359a9cee7b1b887451a15299e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6785541359a9cee7b1b887451a15299e">&#9670;&nbsp;</a></span>downsample_lttb_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LazyMatrix::downsample_lttb_matrix </td>
          <td>(</td>
          <td class="paramtype">const MatrixType1 &amp;&#160;</td>
          <td class="paramname"><em>source_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType2 &amp;&#160;</td>
          <td class="paramname"><em>destination_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>end_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sample_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Downsamples each column or row of a matrix using the Largest Triangle Three Buckets (LTTB) algorithm. </p>
<p >This function applies the LTTB algorithm to independently downsample each column or row of the source matrix. It is useful for reducing the number of data points in a matrix while preserving the visual shape of the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_matrix</td><td>The source matrix containing the original data points. </td></tr>
    <tr><td class="paramname">destination_matrix</td><td>The destination matrix where the downsampled data will be stored. </td></tr>
    <tr><td class="paramname">start_index</td><td>The starting index for downsampling. </td></tr>
    <tr><td class="paramname">end_index</td><td>The ending index for downsampling. </td></tr>
    <tr><td class="paramname">sample_rows</td><td>If true, rows will be downsampled; if false, columns will be downsampled.</td></tr>
  </table>
  </dd>
</dl>
<p>Example usage:</p><ul>
<li>Downsample columns: downsample_lttb_matrix(source_matrix, destination_matrix, 0, source_matrix.columns() - 1, false);</li>
<li>Downsample rows: downsample_lttb_matrix(source_matrix, destination_matrix, 0, source_matrix.rows() - 1, true); </li>
</ul>

</div>
</div>
<a id="a6eee1e0458366cad64664bb830404d55" name="a6eee1e0458366cad64664bb830404d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eee1e0458366cad64664bb830404d55">&#9670;&nbsp;</a></span>downsample_lttb_matrix_xy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{} &amp;&amp;<a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LazyMatrix::downsample_lttb_matrix_xy </td>
          <td>(</td>
          <td class="paramtype">const MatrixType1 &amp;&#160;</td>
          <td class="paramname"><em>source_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType2 &amp;&#160;</td>
          <td class="paramname"><em>destination_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>x_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>end_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sample_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Downsamples each column or row of a matrix using the Largest Triangle Three Buckets (LTTB) algorithm for x/y graph downsampling. </p>
<p >This function applies the LTTB algorithm to independently downsample each column or row of the source matrix in the context of x/y graph data. One row (or column) is used as the x-axis data for all downsampled y-axis data. The x_index can be any integer, as circ_at handles circular and negative indexing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_matrix</td><td>The source matrix containing the original data points. </td></tr>
    <tr><td class="paramname">destination_matrix</td><td>The destination matrix where the downsampled data will be stored. </td></tr>
    <tr><td class="paramname">x_index</td><td>The index of the row (or column) representing the x-axis, can be any integer. </td></tr>
    <tr><td class="paramname">start_index</td><td>The starting index for downsampling. </td></tr>
    <tr><td class="paramname">end_index</td><td>The ending index for downsampling. </td></tr>
    <tr><td class="paramname">sample_rows</td><td>If true, rows will be downsampled; if false, columns will be downsampled.</td></tr>
  </table>
  </dd>
</dl>
<p>Note: The function returns immediately if the size of either source or destination matrix is zero. </p>

</div>
</div>
<a id="a468302541b193bf6ed59502d558abc0d" name="a468302541b193bf6ed59502d558abc0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a468302541b193bf6ed59502d558abc0d">&#9670;&nbsp;</a></span>downsample_lttb_xy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType1 , typename MatrixType2 , typename MatrixType3 , typename MatrixType4 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{} &amp;&amp;<a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{} &amp;&amp;<a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType3 &gt;{} &amp;&amp;<a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType4 &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LazyMatrix::downsample_lttb_xy </td>
          <td>(</td>
          <td class="paramtype">const MatrixType1 &amp;&#160;</td>
          <td class="paramname"><em>x_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType2 &amp;&#160;</td>
          <td class="paramname"><em>y_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType3 &amp;&#160;</td>
          <td class="paramname"><em>x_destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType4 &amp;&#160;</td>
          <td class="paramname"><em>y_destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>source_start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>source_end_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Downsampling x/y data points using the Largest Triangle Three Buckets (LTTB) algorithm. </p>
<p >This function applies the LTTB algorithm to downsample a pair of x/y data points, useful for reducing the number of data points in a 2D plot while preserving the visual shape of the data. The function allows specifying start and end indexes for flexible downsampling, including reverse or circular sampling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x_source</td><td>The x-coordinates of the data points. </td></tr>
    <tr><td class="paramname">y_source</td><td>The y-coordinates of the data points. </td></tr>
    <tr><td class="paramname">x_destination</td><td>The x-coordinates of the downsampled data. </td></tr>
    <tr><td class="paramname">y_destination</td><td>The y-coordinates of the downsampled data. </td></tr>
    <tr><td class="paramname">source_start_index</td><td>The starting index in the source data for downsampling. </td></tr>
    <tr><td class="paramname">source_end_index</td><td>The ending index in the source data for downsampling. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade0d9eb480ec17e1a52ed060b4d45b78" name="ade0d9eb480ec17e1a52ed060b4d45b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0d9eb480ec17e1a52ed060b4d45b78">&#9670;&nbsp;</a></span>elem_by_elem_divide()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::elem_by_elem_divide </td>
          <td>(</td>
          <td class="paramtype">const MatrixType1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae15630e1751e3b2dffde567b93eacc00" name="ae15630e1751e3b2dffde567b93eacc00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15630e1751e3b2dffde567b93eacc00">&#9670;&nbsp;</a></span>elem_by_elem_multiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::elem_by_elem_multiply </td>
          <td>(</td>
          <td class="paramtype">const MatrixType1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a344114e97294faa9ba9cf3b2f047b477" name="a344114e97294faa9ba9cf3b2f047b477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a344114e97294faa9ba9cf3b2f047b477">&#9670;&nbsp;</a></span>elem_by_elem_pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::elem_by_elem_pow </td>
          <td>(</td>
          <td class="paramtype">const MatrixType1 &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType2 &amp;&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a11194858277f5ee840a2b83a5af815cf" name="a11194858277f5ee840a2b83a5af815cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11194858277f5ee840a2b83a5af815cf">&#9670;&nbsp;</a></span>execute_python_script()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string LazyMatrix::execute_python_script </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; MatrixType &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; MatrixType &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>script</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>module_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a Python script with given input and output matrices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>The type of the matrices, which must be a matrix type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_matrices</td><td>Vector of pairs of matrix names and references to matrix objects for input. </td></tr>
    <tr><td class="paramname">output_matrices</td><td>Vector of pairs of matrix names and references to matrix objects for output. </td></tr>
    <tr><td class="paramname">script</td><td>The Python script to execute. </td></tr>
    <tr><td class="paramname">module_name</td><td>The Python module to import before executing the python script </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The standard output captured from the Python script. </dd></dl>

</div>
</div>
<a id="a1487dc768908856dcdda2aa9628cea7b" name="a1487dc768908856dcdda2aa9628cea7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1487dc768908856dcdda2aa9628cea7b">&#9670;&nbsp;</a></span>exp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::exp </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3dc11d4549f5d4597dc7c0e3d0e0e57" name="ae3dc11d4549f5d4597dc7c0e3d0e0e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3dc11d4549f5d4597dc7c0e3d0e0e57">&#9670;&nbsp;</a></span>exp2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::exp2 </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a464d2498c6c6db5486ca8e854cd69b8b" name="a464d2498c6c6db5486ca8e854cd69b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464d2498c6c6db5486ca8e854cd69b8b">&#9670;&nbsp;</a></span>fft_moving_window()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LazyMatrix::fft_moving_window </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Matrix&lt; Scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Matrix&lt; std::complex&lt; Scalar &gt;, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>window_duration_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>sampling_period_sec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num_overlap_steps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the moving FFT of a matrix. </p>
<p >This function applies a moving window FFT to a matrix of data, typically used for analyzing time series or signal data. The FFT is computed for each window, and the results are stored in a matrix. Overlapping windows can be specified for more continuous analysis.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar</td><td>The data type of the matrix elements (typically double or float). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The input matrix of data. </td></tr>
    <tr><td class="paramname">result</td><td>The output matrix where FFT results will be stored. </td></tr>
    <tr><td class="paramname">window_duration_sec</td><td>The duration of the time window in seconds. </td></tr>
    <tr><td class="paramname">sampling_period_sec</td><td>The sampling period or frequency of the data in seconds. </td></tr>
    <tr><td class="paramname">num_overlap_steps</td><td>The number of overlap steps between successive windows. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b68a739d329965703cec0b495f67d08" name="a7b68a739d329965703cec0b495f67d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b68a739d329965703cec0b495f67d08">&#9670;&nbsp;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::filter </td>
          <td>(</td>
          <td class="paramtype">const MatrixType1 &amp;&#160;</td>
          <td class="paramname"><em>source_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType2 &amp;&#160;</td>
          <td class="paramname"><em>filter_kernel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies a filter kernel to a source matrix. </p>
<p >This function convolves the source matrix with a filter kernel. It is commonly used for image filtering operations such as blurring, sharpening, and edge detection.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType1</td><td>The type of the source matrix. </td></tr>
    <tr><td class="paramname">MatrixType2</td><td>The type of the filter kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source_matrix</td><td>The matrix to be filtered. </td></tr>
    <tr><td class="paramname">filter_kernel</td><td>The filter kernel to be applied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix&lt;value_type&gt; The filtered matrix. </dd></dl>

</div>
</div>
<a id="a322799145aa54f6fb1441ad7a061c664" name="a322799145aa54f6fb1441ad7a061c664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a322799145aa54f6fb1441ad7a061c664">&#9670;&nbsp;</a></span>from_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int LazyMatrix::from_string </td>
          <td>(</td>
          <td class="paramtype">NumberType &amp;&#160;</td>
          <td class="paramname"><em>resulting_converted_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>position_where_to_begin_converting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>position_where_to_end_converting</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>decimal_point_delimiter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a substring of a string to a number. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NumberType</td><td>The numeric type to which the string will be converted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resulting_converted_number</td><td>The converted numeric result. </td></tr>
    <tr><td class="paramname">string_begin</td><td>Pointer to the beginning of the string to be converted. </td></tr>
    <tr><td class="paramname">position_where_to_begin_converting</td><td>Index in the string to start conversion. </td></tr>
    <tr><td class="paramname">position_where_to_end_converting</td><td>Index in the string to end conversion. </td></tr>
    <tr><td class="paramname">decimal_point_delimiter</td><td>Character used to denote the decimal point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Position in the string where the conversion ended.</dd></dl>
<p>Converts a portion of a string into a numeric value of type NumberType, starting and ending at specified positions. Handles negative numbers and scientific notation. </p>

</div>
</div>
<a id="a2f2204f6c5bde479dc587a1f0a0a0b2d" name="a2f2204f6c5bde479dc587a1f0a0a0b2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2204f6c5bde479dc587a1f0a0a0b2d">&#9670;&nbsp;</a></span>get_absolute_path_of_executable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">fs::path LazyMatrix::get_absolute_path_of_executable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the absolute path of the executable. </p>
<dl class="section return"><dt>Returns</dt><dd>fs::path Absolute path of the executable. </dd></dl>

</div>
</div>
<a id="a468888dced3b3b85673d6da7c479359c" name="a468888dced3b3b85673d6da7c479359c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a468888dced3b3b85673d6da7c479359c">&#9670;&nbsp;</a></span>get_absolute_path_of_executable_parent_directory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">fs::path LazyMatrix::get_absolute_path_of_executable_parent_directory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the absolute directory path of the executable's parent directory. </p>
<dl class="section return"><dt>Returns</dt><dd>fs::path Absolute path of the executable's parent directory. </dd></dl>

</div>
</div>
<a id="a95da13df69fd6c5e47f662af7f3781cf" name="a95da13df69fd6c5e47f662af7f3781cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95da13df69fd6c5e47f662af7f3781cf">&#9670;&nbsp;</a></span>get_circulat_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::get_circulat_iterator </td>
          <td>(</td>
          <td class="paramtype">ContainerType &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>maximum_number_of_rotations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acfca7638e9e4b5310090b56b8c25bcd4" name="acfca7638e9e4b5310090b56b8c25bcd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfca7638e9e4b5310090b56b8c25bcd4">&#9670;&nbsp;</a></span>get_sorted_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LazyMatrix::get_sorted_indices </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sort_by_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>sorted_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modifies a given vector to contain sorted indices based on a matrix row or column. </p>
<p >This function takes an existing vector and resizes it to match the number of elements in the specified row or column of the matrix. It then fills this vector with indices corresponding to these elements and sorts the indices based on the values in the row or column. The sorting is performed in ascending order.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>The type of the matrix expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix expression. </td></tr>
    <tr><td class="paramname">index</td><td>The index of the row or column to be sorted. </td></tr>
    <tr><td class="paramname">sort_by_row</td><td>Boolean flag to indicate row-wise (true) or column-wise (false) sorting. </td></tr>
    <tr><td class="paramname">sorted_indices</td><td>A reference to a vector where sorted indices will be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1540e15d218ea9da477b1bddbcbacd9" name="aa1540e15d218ea9da477b1bddbcbacd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1540e15d218ea9da477b1bddbcbacd9">&#9670;&nbsp;</a></span>list_files_matching_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; fs::path &gt; LazyMatrix::list_files_matching_name </td>
          <td>(</td>
          <td class="paramtype">const fs::path &amp;&#160;</td>
          <td class="paramname"><em>directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name_to_match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List all files in a directory and subdirectories matching a specific name or pattern. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directory</td><td>The directory to search in. </td></tr>
    <tr><td class="paramname">name_to_match</td><td>The name or pattern to match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;fs::path&gt; A vector of file paths that match the given name or pattern. </dd></dl>

</div>
</div>
<a id="ab13bf319e6670370563afdf22c048ca5" name="ab13bf319e6670370563afdf22c048ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13bf319e6670370563afdf22c048ca5">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::max </td>
          <td>(</td>
          <td class="paramtype">const MatrixType1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a64186b53e1042cb11c40599fe839233c" name="a64186b53e1042cb11c40599fe839233c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64186b53e1042cb11c40599fe839233c">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::min </td>
          <td>(</td>
          <td class="paramtype">const MatrixType1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb7ce77ca0421dc366a68b1a2165a149" name="aeb7ce77ca0421dc366a68b1a2165a149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb7ce77ca0421dc366a68b1a2165a149">&#9670;&nbsp;</a></span>operator%()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::operator% </td>
          <td>(</td>
          <td class="paramtype">const MatrixType1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba265586218e5fd2aae76df13f824738" name="aba265586218e5fd2aae76df13f824738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba265586218e5fd2aae76df13f824738">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::operator* </td>
          <td>(</td>
          <td class="paramtype">const MatrixType1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs matrix multiplication between two matrices. </p>
<p >This function overloads the multiplication operator to perform standard matrix multiplication between two matrices of potentially different types. The function employs the classical matrix multiplication algorithm with a time complexity of O(n^3).</p>
<p >Template Parameters: </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType1</td><td>Type of the first matrix (left operand). </td></tr>
    <tr><td class="paramname">MatrixType2</td><td>Type of the second matrix (right operand).</td></tr>
  </table>
  </dd>
</dl>
<p>Function Parameters: </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The first matrix (left operand). </td></tr>
    <tr><td class="paramname">m2</td><td>The second matrix (right operand).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix of type SimpleMatrix&lt;value_type&gt; containing the result of the multiplication. If the matrices are empty or their dimensions do not conform to the requirements of matrix multiplication (i.e., the number of columns in m1 is different from the number of rows in m2), an empty matrix with dimensions (0, 0) is returned. </dd></dl>

</div>
</div>
<a id="a55e7efd6cab7d208d40fc5d17afe5632" name="a55e7efd6cab7d208d40fc5d17afe5632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e7efd6cab7d208d40fc5d17afe5632">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::operator+ </td>
          <td>(</td>
          <td class="paramtype">const MatrixType1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a90966cd3b98a349c315aba4643a517df" name="a90966cd3b98a349c315aba4643a517df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90966cd3b98a349c315aba4643a517df">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::operator- </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f5c87dca6dbf2fc891ad7ee6f622508" name="a6f5c87dca6dbf2fc891ad7ee6f622508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f5c87dca6dbf2fc891ad7ee6f622508">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::operator- </td>
          <td>(</td>
          <td class="paramtype">const MatrixType1 &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType2 &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a28e1509368e1618071336d32eaff2ed0" name="a28e1509368e1618071336d32eaff2ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e1509368e1618071336d32eaff2ed0">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DataType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; LazyMatrix::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLazyMatrix_1_1Interval.html">Interval</a>&lt; DataType &gt; &amp;&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1e4b2ca8fc0a83ef04641067d1db2f1" name="ab1e4b2ca8fc0a83ef04641067d1db2f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e4b2ca8fc0a83ef04641067d1db2f1">&#9670;&nbsp;</a></span>pad_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename DataType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::pad_matrix </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>padded_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>padded_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>constant_value_for_padding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d86e7aefcdf8c692b48970905894c48" name="a2d86e7aefcdf8c692b48970905894c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d86e7aefcdf8c692b48970905894c48">&#9670;&nbsp;</a></span>pad_matrix_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename DataType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::pad_matrix_view </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>padded_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>padded_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DataType &amp;&#160;</td>
          <td class="paramname"><em>constant_value_for_padding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b668ad118aef3b7a858d8b4154a1017" name="a4b668ad118aef3b7a858d8b4154a1017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b668ad118aef3b7a858d8b4154a1017">&#9670;&nbsp;</a></span>repeated_border()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::repeated_border </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a54ad51607eb87a63c4f6aaaf8fec567f" name="a54ad51607eb87a63c4f6aaaf8fec567f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ad51607eb87a63c4f6aaaf8fec567f">&#9670;&nbsp;</a></span>repeated_border_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::repeated_border_view </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0322c2e9962f08ada36f9e784ccfe01" name="ab0322c2e9962f08ada36f9e784ccfe01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0322c2e9962f08ada36f9e784ccfe01">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::reverse </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>should_rows_be_reversed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>should_columns_be_reversed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to create a <a class="el" href="structLazyMatrix_1_1Reverse.html" title="A class that provides a non-modifiable reversed view of a matrix.">Reverse</a> object from a matrix expression. </p>
<p >This function provides an easy way to create a <a class="el" href="structLazyMatrix_1_1Reverse.html" title="A class that provides a non-modifiable reversed view of a matrix.">Reverse</a> object of a given matrix. It checks at compile time if the provided object is a matrix expression and returns a <a class="el" href="structLazyMatrix_1_1Reverse.html" title="A class that provides a non-modifiable reversed view of a matrix.">Reverse</a> object that offers access with reversed rows and/or columns.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>The type of the matrix expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Reference to the matrix expression. </td></tr>
    <tr><td class="paramname">should_rows_be_reversed</td><td>Flag indicating if rows should be reversed. </td></tr>
    <tr><td class="paramname">should_columns_be_reversed</td><td>Flag indicating if columns should be reversed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reverse&lt;MatrixType&gt; A view of the matrix with reversed rows and/or columns. </dd></dl>

</div>
</div>
<a id="adeb270622d381e56b396864d06c2a715" name="adeb270622d381e56b396864d06c2a715"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb270622d381e56b396864d06c2a715">&#9670;&nbsp;</a></span>reverse_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::reverse_view </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>should_rows_be_reversed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>should_columns_be_reversed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to create a <a class="el" href="structLazyMatrix_1_1ReverseView.html" title="A class that provides a reversed view of a matrix.">ReverseView</a> from a matrix expression. </p>
<p >This function provides an easy way to create a <a class="el" href="structLazyMatrix_1_1ReverseView.html" title="A class that provides a reversed view of a matrix.">ReverseView</a> of a given matrix. It checks at compile time if the provided object is a matrix expression and returns a <a class="el" href="structLazyMatrix_1_1ReverseView.html" title="A class that provides a reversed view of a matrix.">ReverseView</a> object that offers access with reversed rows and/or columns.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>The type of the matrix expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Reference to the matrix expression. </td></tr>
    <tr><td class="paramname">should_rows_be_reversed</td><td>Flag indicating if rows should be reversed. </td></tr>
    <tr><td class="paramname">should_columns_be_reversed</td><td>Flag indicating if columns should be reversed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ReverseView&lt;MatrixType&gt; A view of the matrix with reversed rows and/or columns. </dd></dl>

</div>
</div>
<a id="afc8d4d4f34f6faed552e8d8930b12a67" name="afc8d4d4f34f6faed552e8d8930b12a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8d4d4f34f6faed552e8d8930b12a67">&#9670;&nbsp;</a></span>roi()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::roi </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adc0dcb34878fa9ade0f0e7026cd0f809" name="adc0dcb34878fa9ade0f0e7026cd0f809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0dcb34878fa9ade0f0e7026cd0f809">&#9670;&nbsp;</a></span>roi_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::roi_view </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>row1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>column1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>row2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>column2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a505fd6c71a83582a83c331c6d675e634" name="a505fd6c71a83582a83c331c6d675e634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a505fd6c71a83582a83c331c6d675e634">&#9670;&nbsp;</a></span>select_a_single_column()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::select_a_single_column </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>selected_column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd9e10f8127b7d32103c43f47e4dd3d6" name="afd9e10f8127b7d32103c43f47e4dd3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9e10f8127b7d32103c43f47e4dd3d6">&#9670;&nbsp;</a></span>select_a_single_column_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::select_a_single_column_view </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>selected_column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ac13368c99f51cb312c4eb031338a96" name="a8ac13368c99f51cb312c4eb031338a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ac13368c99f51cb312c4eb031338a96">&#9670;&nbsp;</a></span>select_a_single_row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::select_a_single_row </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>selected_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a22e315488009fc272c86dd82df82e943" name="a22e315488009fc272c86dd82df82e943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e315488009fc272c86dd82df82e943">&#9670;&nbsp;</a></span>select_a_single_row_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::select_a_single_row_view </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>selected_row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e5545aa573feba6d945b2dd52039252" name="a1e5545aa573feba6d945b2dd52039252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e5545aa573feba6d945b2dd52039252">&#9670;&nbsp;</a></span>select_columns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::select_columns </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a13b1a8097f36f98dda3d55eda49b5b97" name="a13b1a8097f36f98dda3d55eda49b5b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b1a8097f36f98dda3d55eda49b5b97">&#9670;&nbsp;</a></span>select_columns_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::select_columns_view </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e6fa9752234c6e8258fae6e5d2b0a98" name="a4e6fa9752234c6e8258fae6e5d2b0a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6fa9752234c6e8258fae6e5d2b0a98">&#9670;&nbsp;</a></span>select_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::select_rows </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ccd78dc46b2d4e0ff4add218737d74f" name="a3ccd78dc46b2d4e0ff4add218737d74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ccd78dc46b2d4e0ff4add218737d74f">&#9670;&nbsp;</a></span>select_rows_and_columns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::select_rows_and_columns </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abdb51107cd940a41240794cd28abc035" name="abdb51107cd940a41240794cd28abc035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdb51107cd940a41240794cd28abc035">&#9670;&nbsp;</a></span>select_rows_and_columns_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::select_rows_and_columns_view </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acdd5977f6bb47f1f1f35bb97b2f65958" name="acdd5977f6bb47f1f1f35bb97b2f65958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd5977f6bb47f1f1f35bb97b2f65958">&#9670;&nbsp;</a></span>select_rows_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::select_rows_view </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab85cc8964cfece59793e3c18b5e82601" name="ab85cc8964cfece59793e3c18b5e82601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85cc8964cfece59793e3c18b5e82601">&#9670;&nbsp;</a></span>shuffle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::shuffle </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>should_rows_be_reversed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>should_columns_be_reversed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="addaccc121e5250d7353ab9dd86816805" name="addaccc121e5250d7353ab9dd86816805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addaccc121e5250d7353ab9dd86816805">&#9670;&nbsp;</a></span>shuffle_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::shuffle_view </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>should_rows_be_reversed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>should_columns_be_reversed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f2b173038af9a36bd276324229a4705" name="a1f2b173038af9a36bd276324229a4705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2b173038af9a36bd276324229a4705">&#9670;&nbsp;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::sign </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a775d7e1e0e01bb3a7c08fb0ce155a80e" name="a775d7e1e0e01bb3a7c08fb0ce155a80e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775d7e1e0e01bb3a7c08fb0ce155a80e">&#9670;&nbsp;</a></span>simple_downsampling()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LazyMatrix::simple_downsampling </td>
          <td>(</td>
          <td class="paramtype">const MatrixType1 &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType2 &amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>end_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sample_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Downsamples data from a source matrix to a destination matrix. </p>
<p >This function selectively downsamples either rows or columns from the source matrix based on the specified start and end indices. The flexibility of the 'circ_at' function allows for handling all types of indexing, including reverse and circular sampling.</p>
<p >Examples of usage:</p><ul>
<li>Forward Sampling: If start_index is 0 and end_index is 10, and we are sampling 5 data points, it will sample points at indices 0, 2, 4, 6, and 8.</li>
<li><a class="el" href="structLazyMatrix_1_1Reverse.html" title="A class that provides a non-modifiable reversed view of a matrix.">Reverse</a> Sampling: If start_index is 10 and end_index is 0, it samples in reverse, from index 10 to 0.</li>
<li>Circular Sampling: If start_index is 8 and end_index is 3 in a 10-element matrix, it will wrap around the matrix to sample the data.</li>
</ul>
<p >The source and destination matrices can be different types but must be valid matrix expressions. If downsampling rows, each row represents a data point, and the indices refer to columns. If downsampling columns, each column represents a data point, and the indices refer to rows.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType1</td><td>The type of the source matrix (should support standard indexing operations). </td></tr>
    <tr><td class="paramname">MatrixType2</td><td>The type of the destination matrix (should support standard indexing operations). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source matrix to sample from. </td></tr>
    <tr><td class="paramname">destination</td><td>The destination matrix where sampled data is stored. </td></tr>
    <tr><td class="paramname">start_index</td><td>The starting index for sampling. </td></tr>
    <tr><td class="paramname">end_index</td><td>The ending index for sampling. </td></tr>
    <tr><td class="paramname">sample_rows</td><td>A boolean flag indicating whether to sample rows (true) or columns (false). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18f6d85eded6a2e0d001372717f70391" name="a18f6d85eded6a2e0d001372717f70391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f6d85eded6a2e0d001372717f70391">&#9670;&nbsp;</a></span>simple_moving_average_of_columns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::simple_moving_average_of_columns </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>number_of_data_points_to_average</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e9be71022ab22289bac109a76a2a4ce" name="a9e9be71022ab22289bac109a76a2a4ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9be71022ab22289bac109a76a2a4ce">&#9670;&nbsp;</a></span>simple_moving_average_of_rows()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::simple_moving_average_of_rows </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>number_of_data_points_to_average</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a94c278e5cd0c4fe5b331e93f78aea02b" name="a94c278e5cd0c4fe5b331e93f78aea02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c278e5cd0c4fe5b331e93f78aea02b">&#9670;&nbsp;</a></span>sorted_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::sorted_matrix </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>index_of_row_or_column_to_use_to_sort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sort_by_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab098b2d65f4d9289d13b38951dd5e68f" name="ab098b2d65f4d9289d13b38951dd5e68f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab098b2d65f4d9289d13b38951dd5e68f">&#9670;&nbsp;</a></span>sorted_matrix_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::sorted_matrix_view </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>index_of_row_or_column_to_use_to_sort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sort_by_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af29fe91697a2200da66ae63d1ce0864f" name="af29fe91697a2200da66ae63d1ce0864f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af29fe91697a2200da66ae63d1ce0864f">&#9670;&nbsp;</a></span>sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::sqrt </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6af712f793c89d5e73672e453bda1297" name="a6af712f793c89d5e73672e453bda1297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af712f793c89d5e73672e453bda1297">&#9670;&nbsp;</a></span>strassen_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MatrixType LazyMatrix::strassen_add </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds two matrices. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>Type of the matrices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First matrix. </td></tr>
    <tr><td class="paramname">b</td><td>Second matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sum of the two matrices. </dd></dl>

</div>
</div>
<a id="a47690be30af41c6491a2074ac725294a" name="a47690be30af41c6491a2074ac725294a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47690be30af41c6491a2074ac725294a">&#9670;&nbsp;</a></span>strassen_combine()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MatrixType LazyMatrix::strassen_combine </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>a21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>a22</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines four submatrices into a single matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>Type of the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a11</td><td>Upper left submatrix. </td></tr>
    <tr><td class="paramname">a12</td><td>Upper right submatrix. </td></tr>
    <tr><td class="paramname">a21</td><td>Lower left submatrix. </td></tr>
    <tr><td class="paramname">a22</td><td>Lower right submatrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Combined matrix. </dd></dl>

</div>
</div>
<a id="a66c45411aad33d12c28562a38dc0e542" name="a66c45411aad33d12c28562a38dc0e542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66c45411aad33d12c28562a38dc0e542">&#9670;&nbsp;</a></span>strassen_matrix_multiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::strassen_matrix_multiply </td>
          <td>(</td>
          <td class="paramtype">const MatrixType1 &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType2 &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs matrix multiplication using the Strassen algorithm. </p>
<p >This function implements the Strassen algorithm for efficient matrix multiplication. It first pads the input matrices to dimensions that are powers of two, which optimizes the recursive division process in the Strassen algorithm. After the multiplication, it trims the result back to the original size. This approach is particularly efficient for large matrices where the conventional multiplication becomes computationally expensive.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType1</td><td>Type of the first matrix operand. </td></tr>
    <tr><td class="paramname">MatrixType2</td><td>Type of the second matrix operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first matrix operand, not modified by padding. </td></tr>
    <tr><td class="paramname">b</td><td>The second matrix operand, not modified by padding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classLazyMatrix_1_1Matrix.html" title="Template class for a matrix that utilizes memory-mapped files for storage.">Matrix</a> containing the result of the multiplication.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For matrices smaller or equal to 2x2, this function falls back to conventional matrix multiplication. Padding is applied internally and does not modify the input matrices. </dd></dl>

</div>
</div>
<a id="a0565e3e4beb3355aa4057c3494d01615" name="a0565e3e4beb3355aa4057c3494d01615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0565e3e4beb3355aa4057c3494d01615">&#9670;&nbsp;</a></span>strassen_multiply_recursive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::strassen_multiply_recursive </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively multiplies two matrices using the Strassen algorithm. </p>
<p >Implements the Strassen algorithm to efficiently multiply two matrices. The algorithm recursively divides the matrices into smaller submatrices, computes seven intermediate products, and combines these products to form the final result. This implementation optimizes for generic matrix expressions, using a concrete matrix type for internal computations.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>Type of the matrices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First matrix operand. </td></tr>
    <tr><td class="paramname">b</td><td>Second matrix operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of multiplying matrices a and b.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For matrices smaller than or equal to 2x2, the function falls back to conventional matrix multiplication. </dd></dl>

</div>
</div>
<a id="ac1b723cc31bd0c1ca561c409a77bb5a0" name="ac1b723cc31bd0c1ca561c409a77bb5a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b723cc31bd0c1ca561c409a77bb5a0">&#9670;&nbsp;</a></span>strassen_split()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType1 , typename MatrixType2 , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType1 &gt;{}&gt; *  = nullptr, std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType2 &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LazyMatrix::strassen_split </td>
          <td>(</td>
          <td class="paramtype">const MatrixType1 &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType2 &amp;&#160;</td>
          <td class="paramname"><em>a11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType2 &amp;&#160;</td>
          <td class="paramname"><em>a12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType2 &amp;&#160;</td>
          <td class="paramname"><em>a21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType2 &amp;&#160;</td>
          <td class="paramname"><em>a22</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a matrix into four equal submatrices. </p>
<p >This function divides a given matrix into four submatrices. The split occurs at the midpoint of the rows and columns of the matrix. It's used as a part of the Strassen algorithm for matrix multiplication.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType1</td><td>Type of the source matrix. </td></tr>
    <tr><td class="paramname">MatrixType2</td><td>Type of the submatrices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix to be split. </td></tr>
    <tr><td class="paramname">a11</td><td>Upper left submatrix. </td></tr>
    <tr><td class="paramname">a12</td><td>Upper right submatrix. </td></tr>
    <tr><td class="paramname">a21</td><td>Lower left submatrix. </td></tr>
    <tr><td class="paramname">a22</td><td>Lower right submatrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6238a2b46de481cac9454d09177c9ecf" name="a6238a2b46de481cac9454d09177c9ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6238a2b46de481cac9454d09177c9ecf">&#9670;&nbsp;</a></span>strassen_subtract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MatrixType LazyMatrix::strassen_subtract </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subtracts one matrix from another. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>Type of the matrices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First matrix. </td></tr>
    <tr><td class="paramname">b</td><td>Second matrix to subtract from the first. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the subtraction. </dd></dl>

</div>
</div>
<a id="adb8b0ee561b071e49c1b95a78ff917ba" name="adb8b0ee561b071e49c1b95a78ff917ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8b0ee561b071e49c1b95a78ff917ba">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::transpose </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to create a <a class="el" href="classLazyMatrix_1_1Transpose.html" title="A class that provides a read-only transposed view of a matrix.">Transpose</a> from a matrix expression. </p>
<p >This function provides an easy way to create a <a class="el" href="classLazyMatrix_1_1Transpose.html" title="A class that provides a read-only transposed view of a matrix.">Transpose</a> of a given matrix. It checks at compile time if the provided object is a matrix expression and returns a <a class="el" href="classLazyMatrix_1_1Transpose.html" title="A class that provides a read-only transposed view of a matrix.">Transpose</a> object that offers read-only access.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>The type of the matrix expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Reference to the matrix expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Transpose&lt;MatrixType&gt; A read-only transposed view of the matrix expression. </dd></dl>

</div>
</div>
<a id="a1e4fb5b5932ae2e59b0a24f8cd82828a" name="a1e4fb5b5932ae2e59b0a24f8cd82828a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4fb5b5932ae2e59b0a24f8cd82828a">&#9670;&nbsp;</a></span>transpose_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::transpose_view </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to create a <a class="el" href="classLazyMatrix_1_1TransposeView.html" title="A view class that provides a transposed view of a matrix.">TransposeView</a> from a matrix expression. </p>
<p >This function provides an easy way to create a <a class="el" href="classLazyMatrix_1_1TransposeView.html" title="A view class that provides a transposed view of a matrix.">TransposeView</a> of a given matrix. It checks at compile time if the provided object is a matrix expression and returns a <a class="el" href="classLazyMatrix_1_1TransposeView.html" title="A view class that provides a transposed view of a matrix.">TransposeView</a> object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>The type of the matrix expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Reference to the matrix expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TransposeView&lt;MatrixType&gt; A transposed view of the matrix expression. </dd></dl>

</div>
</div>
<a id="af97384febee24becf2e685e3853d626a" name="af97384febee24becf2e685e3853d626a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97384febee24becf2e685e3853d626a">&#9670;&nbsp;</a></span>trim_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MatrixType LazyMatrix::trim_matrix </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trims a matrix to the specified size. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>Type of the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix to be trimmed. </td></tr>
    <tr><td class="paramname">rows</td><td>Number of rows in the trimmed matrix. </td></tr>
    <tr><td class="paramname">cols</td><td>Number of columns in the trimmed matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Trimmed matrix. </dd></dl>

</div>
</div>
<a id="a75ffdde83316599a2cb05990ea23fe12" name="a75ffdde83316599a2cb05990ea23fe12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ffdde83316599a2cb05990ea23fe12">&#9670;&nbsp;</a></span>wrap_in_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SimpleDataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLazyMatrix_1_1SimpleData2DMatrixWrapper.html">SimpleData2DMatrixWrapper</a>&lt; SimpleDataType &gt; LazyMatrix::wrap_in_matrix </td>
          <td>(</td>
          <td class="paramtype">const SimpleDataType &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a 2d-matrix-like wrapper for a simple data value. </p>
<p >This function takes a simple data type and wraps it in a <code><a class="el" href="classLazyMatrix_1_1SimpleData2DMatrixWrapper.html" title="A wrapper class for simple data types to provide a 2D matrix-like interface.">SimpleData2DMatrixWrapper</a></code>, allowing it to be used in contexts that expect a matrix-like object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SimpleDataType</td><td>The type of the simple data to be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SimpleData2DMatrixWrapper&lt;SimpleDataType&gt; The wrapped matrix-like object. </dd></dl>

</div>
</div>
<a id="aa5da7f79d1ca021a844d3b6c03b85428" name="aa5da7f79d1ca021a844d3b6c03b85428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5da7f79d1ca021a844d3b6c03b85428">&#9670;&nbsp;</a></span>wrap_in_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SimpleDataType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLazyMatrix_1_1SimpleData3DMatrixWrapper.html">SimpleData3DMatrixWrapper</a>&lt; SimpleDataType &gt; LazyMatrix::wrap_in_matrix </td>
          <td>(</td>
          <td class="paramtype">const SimpleDataType &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a 3d-matrix-like wrapper for a simple data value. </p>
<p >This function takes a simple data type and wraps it in a <code><a class="el" href="classLazyMatrix_1_1SimpleData2DMatrixWrapper.html" title="A wrapper class for simple data types to provide a 2D matrix-like interface.">SimpleData2DMatrixWrapper</a></code>, allowing it to be used in contexts that expect a matrix-like object.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SimpleDataType</td><td>The type of the simple data to be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SimpleData2DMatrixWrapper&lt;SimpleDataType&gt; The wrapped matrix-like object. </dd></dl>

</div>
</div>
<a id="af71c2a2d595f0ed582efdef1cb3ba779" name="af71c2a2d595f0ed582efdef1cb3ba779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71c2a2d595f0ed582efdef1cb3ba779">&#9670;&nbsp;</a></span>wrap_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix.html">is_type_a_matrix</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::wrap_matrix </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps a matrix in a <a class="el" href="classLazyMatrix_1_1PolymorphicMatrixWrapper.html" title="Wrapper class that provides a polymorphic interface to a given matrix type.">PolymorphicMatrixWrapper</a> and returns a shared pointer to <a class="el" href="classLazyMatrix_1_1PolymorphicMatrix.html" title="Base class providing a polymorphic interface for matrix-like data.">PolymorphicMatrix</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>Type of the matrix to wrap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix to be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::shared_ptr&lt;PolymorphicMatrix&lt;value_type&gt;&gt; Shared pointer to the base polymorphic type of the wrapped matrix. </dd></dl>

</div>
</div>
<a id="a038becb75eae0652944432579f77e0ef" name="a038becb75eae0652944432579f77e0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038becb75eae0652944432579f77e0ef">&#9670;&nbsp;</a></span>wrap_matrix3d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , std::enable_if_t&lt; <a class="el" href="structLazyMatrix_1_1is__type__a__matrix3d.html">is_type_a_matrix3d</a>&lt; MatrixType &gt;{}&gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto LazyMatrix::wrap_matrix3d </td>
          <td>(</td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wraps a matrix in a <a class="el" href="classLazyMatrix_1_1PolymorphicMatrixWrapper3D.html" title="Wrapper class that provides a polymorphic interface to a given 3d-matrix type.">PolymorphicMatrixWrapper3D</a> and returns a shared pointer to <a class="el" href="classLazyMatrix_1_1PolymorphicMatrix3D.html" title="Base class providing a polymorphic interface for 3d-matrix-like data.">PolymorphicMatrix3D</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>Type of the 3d-matrix to wrap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix to be wrapped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::shared_ptr&lt;PolymorphicMatrix&lt;value_type&gt;&gt; Shared pointer to the base polymorphic type of the wrapped matrix. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae858a6ae5c52bcd785b123e3b09e55e5" name="ae858a6ae5c52bcd785b123e3b09e55e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae858a6ae5c52bcd785b123e3b09e55e5">&#9670;&nbsp;</a></span>matrix3d_footer_byte_sequence</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string LazyMatrix::matrix3d_footer_byte_sequence = &quot;:---end_3d_---:\n&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a796191179d49aed39ac92eb89cc8d1ea" name="a796191179d49aed39ac92eb89cc8d1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a796191179d49aed39ac92eb89cc8d1ea">&#9670;&nbsp;</a></span>matrix3d_header_byte_sequence</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string LazyMatrix::matrix3d_header_byte_sequence = &quot;---begin_3d_---\n&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a90114cc2fd66533f72fb96dd5fff14f7" name="a90114cc2fd66533f72fb96dd5fff14f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90114cc2fd66533f72fb96dd5fff14f7">&#9670;&nbsp;</a></span>matrix_footer_byte_sequence</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string LazyMatrix::matrix_footer_byte_sequence = &quot;::----end----::\n&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5f7e3530431416e7b92f68c895c0b3b" name="ae5f7e3530431416e7b92f68c895c0b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f7e3530431416e7b92f68c895c0b3b">&#9670;&nbsp;</a></span>matrix_header_byte_sequence</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string LazyMatrix::matrix_header_byte_sequence = &quot;::---begin---::\n&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
